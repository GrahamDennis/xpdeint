#!/usr/bin/env python
# encoding: utf-8
"""
wscript

The waf script to configure compilation of generated simulations.

Created by Graham Dennis on 2009-03-01.
"""

import os

import Task
import TaskGen
from TaskGen import feature
from Constants import ASK_LATER, SKIP_ME, RUN_ME

srcdir = '.'
blddir = 'waf_build'

from xpdeint import Configuration

def set_options(opt):
    # options provided by modules
    opt.tool_options('compiler_cxx')


def configure(conf):
    for key, value in Configuration.wafArguments.iteritems():
        conf.env[key] = value
    
    def check_cxx(**KWs):
        result = conf.check_cxx(**KWs)
        if result and 'uselib_store' in KWs:
            conf.env.append_unique('uselib', KWs['uselib_store'])
            if 'header_name' in KWs:
                conf.env.append_unique('HEADER_%s' % KWs['uselib_store'], KWs['header_name'])
        return result
    
    mpi = conf.env.copy()
    mpi.set_variant('mpi')
    conf.set_env_name('mpi', mpi)
    conf.setenv('default')
    single = conf.env.copy()
    single.set_variant('default')
    conf.set_env_name('default', single)
    conf.setenv('default')
    
    def try_options(uselib_store, kwOptions, common = None):
        common = common or {}
        for kws in kwOptions:
            allKWs = common.copy()
            allKWs.update(kws)
            if check_cxx(uselib_store=uselib_store, **allKWs):
                break
    
    
    def configure_compiler():
        conf.check_tool('compiler_cxx')
        conf.check_tool('osx')
        
        if conf.env['CXX_NAME'] == 'gcc':
            machine_optimisations = [
                {
                    "msg": "Trying to make compiler optimise for this machine",
                    "cxxflags": "-march=native",
                },
                {
                    "msg": "Checking for Altivec",
                    "cxxflags": '-maltivec',
                },
                {
                    "msg": "Checking for SSE3",
                    "cxxflags": ["-msse3", "-msse2", "-msse", "-mfpmath=sse"],
                },
                {
                    "msg": "Checking for SSE2",
                    "cxxflags": ["-msse2", "-msse", "-mfpmath=sse"],
                },
                {
                    "msg": "Checking for SSE",
                    "cxxflags": ["-msse", "-mfpmath=sse"]
                }
            ]
            
            try_options('optimise', machine_optimisations)
            
            check_cxx(
                cxxflags='-mtune=native',
                uselib_store="optimise",
                msg = "Trying to make compiler tune for this machine"
            )
            
            compiler_optimisations = [
                {
                    "msg": "Checking for the 'go fast' compiler option",
                    "cxxflags": ["-fast", "-ffast-math"],
                },
                {
                    "msg": "Checking for fallback optimisation flags",
                    "cxxflags": ['-O3', '-ffast-math', '-funroll-all-loops', '-fomit-frame-pointer'],
                }
            ]
            
            try_options('optimise', compiler_optimisations)
            
            check_cxx(
                cxxflags=['-fno-unsafe-math-optimizations', '-fno-finite-math-only'],
                uselib_store="safe_math",
                uselib='optimise',
                msg = "Checking for cautious math flags"
            )
            
            check_cxx(
                cxxflags='-ftree-vectorize',
                uselib_store='vectorise',
                uselib="optimise",
                msg = "Checking for Autovectorisation"
            )
            
            check_cxx(
                cxxflags='-openmp',
                uselib_store='openmp',
                msg = "Checking for OpenMP"
            )
            
            check_cxx(
                cxxflags="-pthread",
                linkflags="-pthread",
                uselib_store="threads",
                msg = "Checking for pthreads",
            )
        elif conf.env['CXX_NAME'] == 'icc':
            check_cxx(
                cxxflags="-fast",
                uselib_store="optimise",
                msg = "Checking for the 'go fast' compiler option"
            )
            
            check_cxx(
                cxxflags="-fma",
                uselib_store="optimise",
                msg = "Trying to fuse multiply and add instructions"
            )
            
            check_cxx(
                cxxflags = ["-fp-model", "precise"],
                uselib_store="safe_math",
                uselib="optimise",
                msg = "Checking for cautious math flags"
            )
            
            check_cxx(
                cxxflags = "-vec",
                uselib_store="vectorise",
                uselib="optimise",
                msg = "Checking for Autovectorisation"
            )
            
            check_cxx(
                cxxflags='-openmp',
                linkflags="-openmp",
                uselib_store="openmp",
                msg = "Checking for OpenMP"
            )
            
            check_cxx(
                cxxflags="-pthread",
                linkflags="-pthread",
                uselib_store="threads",
                msg = "Checking for pthreads"
            )
        
        
        check_cxx(
            cxxflags="-g",
            uselib_store="debug",
            msg = "Checking for compiler debug flags"
        )
        
        check_cxx(
            lib='hdf5',
            header_name=['hdf5.h'],
            function_name='H5check_version',
            uselib_store='hdf5',
            msg = 'Checking for HDF5'
        )
        
        if 'hdf5' in conf.env['uselib']:
            check_cxx(
                defines='HAVE_HDF5_HL',
                lib='hdf5_hl',
                header_name=['hdf5.h', 'hdf5_hl.h'],
                function_name='H5DSset_scale',
                uselib_store='hdf5',
                uselib = 'hdf5',
                msg = "Checking for HDF5 High-level library"
            )
            check_cxx(
                header_name=['hdf5.h'],
                defines='HAVE_H5LEXISTS',
                function_name='H5Lexists',
                uselib = 'hdf5',
                uselib_store = 'hdf5'
            )
        
        check_cxx(
            lib='xmds',
            # function_name='initialiseFieldFromXSILFile',
            uselib_store='xmds',
            msg = "Checking for libxmds"
        )
        
        # Ways of linking GSL
        gsl_options = [
            {
                "lib": 'gsl',
                "msg": "Checking for GSL",
            },
            {
                "lib": ["gsl", "gslcblas"],
                "msg": "Checking if GSL requires -lgslcblas",
            }
        ]
        gsl_common = {
            'header_name': 'gsl/gsl_sf.h',
            'function_name': 'gsl_sf_bessel_jl',
        }
        try_options("gsl", gsl_options, gsl_common)
        
        check_cxx(
            lib=["iomp", "vml"],
            header_name='mkl_vsl.h',
            function_name='vslNewStream',
            uselib_store='mkl_vsl',
            msg = "Checking for Intel's Vector Math Library"
        )
        
        check_cxx(
            cxxflags=["-finline-functions", "-fno-strict-aliasing", "--param", "max-inline-insns-single=1800"],
            uselib_store="dsfmt",
            msg = "Checking dSFMT's compile flags",
        )
        
        # Find CBLAS
        cblas_options = [
            {# Intel MKL
                'defines': 'CBLAS_MKL',
                'lib': ['mkl_intel_lp64', 'mkl_intel_thread', 'mkl_core'],
                'linkflags': '-openmp', # FIXME: Dodgy hack. We should mark the uselib 'openmp' as a dependency
                'header_name': 'mkl.h',
                'msg': "Checking for Intel's Math Kernel Library",
            },
            {# Apple vecLib
                'defines': 'CBLAS_VECLIB',
                'framework_name': 'vecLib',
                'msg': "Checking for Apple's vecLib framework",
            },
            {# ATLAS CBLAS
                'defines': 'CBLAS_ATLAS',
                'lib': 'cblas',
                'header_name': 'cblas.h',
                'msg': "Checking for ATLAS's CBLAS."
            },
            {# GSL CBLAS
                'defines': 'CBLAS_GSL',
                'lib': 'gslcblas',
                'header_name': 'gsl/gsl_cblas.h',
                'msg': "Checking for GSL's CBLAS",
            }
        ]
        cblas_common = {
            'function_name': 'cblas_dgemm',
        }
        
        try_options('cblas', cblas_options, cblas_common)
        
        check_cxx(
            lib='fftw3',
            header_name='fftw3.h',
            function_name='fftw_execute',
            uselib_store='fftw3',
            msg = "Checking for FFTW3"
        )
        
        check_cxx(
            lib='fftw3f',
            header_name='fftw3.h',
            function_name='fftwf_execute',
            uselib_store='fftw3f',
            msg = "Checking for single-precision FFTW3"
        )
        
        if 'fftw3' in conf.env['uselib']:
            check_cxx(
                lib='fftw3_threads',
                header_name='fftw3.h',
                function_name='fftw_init_threads',
                uselib_store='fftw3_threads',
                uselib=['fftw3', 'threads'],
                msg = "Checking for threading support in FFTW3",
            )
        if 'fftw3f' in conf.env['uselib']:
            check_cxx(
                lib='fftw3f_threads',
                header_name='fftw3.h',
                function_name='fftwf_init_threads',
                uselib_store='fftw3f_threads',
                uselib=['fftw3f', 'threads'],
                msg = "Checking for threading support in single-precision FFTW3",
            )
        
    
    print
    print "Configuring for single-process scripts..."
    configure_compiler()
    
    # Stuff for MPI variant
    print
    print "Configuring for MPI scripts..."
    conf.setenv('mpi')
    if conf.find_program('mpic++', var='MPICXX'):
        
        conf.env['CXX'] = conf.env['MPICXX']
        conf.env['LINK_CXX'] = conf.env['MPICXX']
        
        configure_compiler()
        
        if 'fftw3' in conf.env['uselib']:
            check_cxx(
                lib='fftw3_mpi',
                header_name='fftw3.h fftw3-mpi.h',
                function_name='fftw_mpi_init',
                uselib_store='fftw3_mpi',
                uselib='fftw3',
                msg = "Checking for FFTW3 with MPI"
            )
        if 'fftw3f' in conf.env['uselib']:
            check_cxx(
                lib='fftw3f_mpi',
                header_name='fftw3.h fftw3-mpi.h',
                function_name='fftwf_mpi_init',
                uselib_store='fftw3f_mpi',
                uselib='fftw3f',
                msg = "Checking for single-precision FFTW3 with MPI"
            )
    else:
        print "MPI not found. No scripts using MPI can be compiled on this system."
        del conf.all_envs['mpi']
    
    # Restore default environment and check compiler flags
    conf.setenv('default')

def build(bld):
    Configuration.availableUselib = bld.env_of_name(Configuration.buildVariant)['uselib']
    Configuration.availableVariants = bld.all_envs.keys()
    
    if not Configuration.buildVariant in Configuration.availableVariants:
        return
    
    obj = bld.new_task_gen(
        features = 'cxx cprogram',
        source=Configuration.xpdeintSourcePlaceholder,
        target=Configuration.xpdeintTargetPlaceholder,
        link = 'xpdeint_link',
        env = bld.env_of_name(Configuration.buildVariant),
        **Configuration.wafArguments
    )
    
    obj.rule = '${CXX} ${CXX_SRC_F}${SRC} ${CXXFLAGS} ${CPPFLAGS} ${_CXXINCFLAGS} ${_CXXDEFFLAGS}'
    
    @feature('cxx')
    def xpdeint_dodgy_hack(self):
        
        def dont_run(self):
            self.run()
            return SKIP_ME
        def save_command(self, lst, cwd=None):
            if self.__class__.__name__ == 'xpdeint_link':
                Configuration.waf_link_command_callback(lst)
            else:
                Configuration.waf_compile_command_callback(lst)
            
        for task in self.tasks:
            task.__class__.runnable_status = dont_run
            task.__class__.exec_command = save_command
    
    
    TaskGen.declare_order('apply_core', 'xpdeint_dodgy_hack')
    

xpdeint_link_str = '${LINKFLAGS} ${CXXLNK_TGT_F}${TGT}'
cls = Task.simple_task_type('xpdeint_link', xpdeint_link_str, color='YELLOW')


