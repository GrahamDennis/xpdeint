@*
Operator.tmpl

Created by Graham Dennis on 2007-10-13.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Operators._Operator

@from xpdeint.Vectors.VectorElement import VectorElement

@def functionPrototypes
  @#
  @super
  @#
  @if $operatorVector
void _${parent.id}_calculate_${name}_field($calculateOperatorFieldFunctionArgumentString);
  @end if
void _${parent.id}_evaluate_${name}(${evaluateOperatorFunctionArgumentString});
  @#
@end def

@def functionImplementations
  @#
  @super
  @#
  @if $operatorVector
      
${calculateOperatorFieldFunctionImplementation}@slurp
  @end if

${evaluateOperatorFunctionImplementation}@slurp

  @#
@end def

@def calculateOperatorFieldFunctionImplementation
  @#
// ${description}
void _${parent.id}_calculate_${name}_field(${calculateOperatorFieldFunctionArgumentString})
{
  ${calculateOperatorFieldFunctionContents, autoIndent=True}@slurp
}
  @#
@end def

@def evaluateOperatorFunctionImplementation
  @#
// ${description}
void _${parent.id}_evaluate_${name}(${evaluateOperatorFunctionArgumentString})
{
  ${evaluateOperatorFunctionContents, autoIndent=True}@slurp
}
  @#
@end def


@def insideEvaluateOperatorLoops
  @#
  @# Content must be provided by a subclass
  @assert 0
  @#
@end def

@def allocate
  @#
  @for $vector in filter(lambda x: isinstance(x, VectorElement), $children)
${vector.allocate}@slurp
  @end for
  @#
@end def

@def initialise
  @#
${allocate}@slurp
  @#
  @if $operatorVector
_${parent.id}_calculate_${name}_field();
  @end if
  @#
@end def

@def finalise
  @#
  @for $vector in filter(lambda x: isinstance(x, VectorElement), $children)
${vector.free}@slurp
  @end for
  @#
@end def

@def calculateOperatorFieldFunctionContents
  @#
  @for $operatorComponentName in $operatorComponents.iterkeys()
complex $operatorComponentName;
  @end for
  @#
${transformVectorsToSpace($dependencies, $operatorSpace)}@slurp

  @set $vectorsToLoopOver = $dependencies.copy()
  @silent $vectorsToLoopOver.add($operatorVector)
${loopOverFieldInSpaceWithVectorsAndInnerContent($loopingField, $operatorSpace, $vectorsToLoopOver, $insideCalculateOperatorFieldLoops)}@slurp
  @#
@end def

@attr $evaluateOperatorFunctionArgument = 'double _step'

@def evaluateOperatorFunctionContents
  @#
  @# We need to loop over the operator vector (if we have one),
  @# all of the vectors to which we are applying any of our operators,
  @# any dependencies, and the vector containing the result of this
  @# operator evaluation
  @#
  @set $setOfVectorsToLoopOver = set()
  @silent $setOfVectorsToLoopOver.update($targetVectors)
${transformVectorsToSpace($setOfVectorsToLoopOver, $operatorSpace)}@slurp
  @#

  @if $operatorVector
    @# If we have an operator vector, we will need to loop over it
    @silent $setOfVectorsToLoopOver.add($operatorVector)
  @else
    @# If we don't have an operator vector, then we will need our dependencies here
    @silent $setOfVectorsToLoopOver.update($dependencies)
    @# If we don't have an operator vector, then we need to create
    @# the component variables so that the user can set them inside
    @# the loop
    @for $operatorComponentName, $operatorComponentDictionary in $operatorComponents.iteritems()
      @set $typeNamesSet = set([vector.type for vector in operatorComponentDictionary.iterkeys()])
      @set $typeName = 'double'
      @if 'complex' in typeNamesSet
        @set $typeName = 'complex'
      @end if
${typeName} ${operatorComponentName};
    @end for

  @end if
  @#
  @# If we have a result vector, add it
  @if $resultVector
    @silent $setOfVectorsToLoopOver.add($resultVector)
  @end if
  @#

${evaluateOperatorLoop($setOfVectorsToLoopOver)}@slurp
  @#
  @if $resultVector and $resultVector.needsFourierTransforms

_${resultVector.id}_space = $operatorSpace;
  @end if
  @#
@end def

@def evaluateOperatorLoop($setOfVectorsToLoopOver)
  @#
  @if $operatorVector
    @# If we have an operator vector, then there is no user code in this loop
${loopOverVectorsInSpaceWithInnerContent($setOfVectorsToLoopOver, $operatorSpace, $insideEvaluateOperatorLoops)}@slurp
  @else
    @# If we don't have an operator vector, then we will be looping over user code.
    @#
    @# If we have a result vector, then we need to add that to the loop
    @if $resultVector
      @silent $setOfVectorsToLoopOver.add($resultVector)
    @end if
${loopOverFieldInSpaceWithVectorsAndInnerContent($loopingField, $operatorSpace, $setOfVectorsToLoopOver, $insideEvaluateOperatorLoops)}@slurp
  @end if
  @#
@end def
