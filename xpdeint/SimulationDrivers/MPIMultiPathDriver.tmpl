@*
MPIMultiPathDriver.tmpl

Created by Graham Dennis on 2008-02-25.
Copyright (c) 2008 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.SimulationDrivers._MPIMultiPathDriver

@def description: MPI Multipath Simulation Driver

@def mainRoutine
  @#
int main(int argc, char **argv)
{
  MPI_Init(&argc, &argv);
  MPI_Comm_size(MPI_COMM_WORLD, &_size);
  MPI_Comm_rank(MPI_COMM_WORLD, &_rank);
  
  @for $field in $fields
  ${field.allocate, autoIndent=True}@slurp
    @if $field.isOutputField
  ${field.initialise, autoIndent=True}@slurp
    @end if
  @end for
  
  ${mainRoutineInnerContent, autoIndent=True}@slurp
  
  MPI_Finalize();
  
  return 0;
}
  @#
@end def


@def topLevelSegmentFunctionImplementation
  @#
void _segment0()
{
  @# And now insert the code for the features that apply in the top level sequence
  @set $featureOrdering = ['ErrorCheck', 'Stochastic']
  @set $dict = {'extraIndent': 0}
  ${insertCodeForFeatures('topLevelSequenceBegin', featureOrdering, dict), autoIndent=True}@slurp
  @set $extraIndent = dict['extraIndent']
  
  ${topLevelSegmentPathLoop, autoIndent=True, extraIndent=extraIndent}@slurp
  
  ${insertCodeForFeaturesInReverseOrder('topLevelSequenceEnd', featureOrdering, dict), autoIndent=True}@slurp
  
  @for mg in $momentGroups
    @for vector in mg.outputField.managedVectors
      @set $arrayNames = [c'_${vector.id}']
      @silent $arrayNames.extend($vector.aliases)
      @for arrayName in arrayNames
  
  if (_rank == 0)
    MPI_Reduce(MPI_IN_PLACE, $arrayName, ${sizeOfVectorInSpaceInReals(vector, mg.outputSpace)},
               MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  else
    MPI_Reduce($arrayName, NULL, ${sizeOfVectorInSpaceInReals(vector, mg.outputSpace)},
               MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
      @end for
    @end for
  @end for
}
  @#
@end def

@def topLevelSegmentPathLoop
  @#
  @# Now loop over anything that can be initalised early and initialise them
  @# so they don't allocate and free stuff for each path. This is done now
  @# and not before the ErrorCheck and Stochastic Features because the
  @# initialisation of IP operators will depend on the step size. It would be
  @# possible to split this up into two stages of initialisation, but that
  @# seems to me like it would be ugly.
  @# 
  @set $objectsNeedingInitialisation = [o for o in $templates if o.hasattr('canBeInitialisedEarly') and o.canBeInitialisedEarly]
  @for o in $objectsNeedingInitialisation
${o.initialise}@slurp
  @end for
  @#
for (long _i0 = _rank; _i0 < _n_paths; _i0 += _size) {
  _LOG(_PATH_LOG_LEVEL, "Starting path %li\n", _i0 + 1);
  
  ${topLevelSequence.topLevelSequenceInnerContent, autoIndent=True}@slurp
}
  @#
  @# Now clean up after all of the objects that we initialised early.
  @for o in $objectsNeedingInitialisation
${o.finalise}@slurp
  @end for
  @#
@end def

@def writeOutBegin($dict)
  @#
// If we aren't rank 0, then we don't want to write anything.
if (_rank != 0)
  return;
  @#
@end def
