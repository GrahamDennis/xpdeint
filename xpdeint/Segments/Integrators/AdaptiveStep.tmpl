F@*
AdaptiveStep.tmpl

Created by Graham Dennis on 2007-11-16.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Segments.Integrators.Integrator

@def description: segment $segmentNumber (Unnamed adaptive-step integrator)

@*
  Function prototypes
*@
@def functionPrototypes
  @#
  @super
  @#
double _segment${segmentNumber}_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter);
  @#
  @for $vector in $integrationVectors
double _segment${segmentNumber}_${vector.id}_timestep_error(${vector.type}* _checkfield);
void _segment${segmentNumber}_${vector.id}_reset(${vector.type}* _reset_to);
  @end for
  @#
@end def


@*
  Function implementations
*@
@def functionImplementations
  @#
  @super
  @#
${setupSamplingFunctionImplementation}@slurp
  @for $vector in $integrationVectors

${timestepErrorFunctionImplementation($vector)}@slurp

${resetFunctionImplementation($vector)}@slurp
  @end for
  @#
@end def


@def setupSamplingFunctionImplementation
  @#
double _segment${segmentNumber}_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter)
{
  // The numbers of the moment groups that need to be sampled at the next sampling point.
  // An entry of N+1 means "reached end of integration interval"
  long _momentGroupNumbersNeedingSamplingNext[${len($samples) + 1}];
  long _numberOfMomentGroupsToBeSampledNext = 1;
  
  long _previous_m = 1;
  long _previous_M = 1;
  
  double _${propagationDimension}_break_next = (double)${interval};
  _momentGroupNumbersNeedingSamplingNext[0] = ${len($samples)};
  
  // initialise all flags to false
  for (long _i0 = 0; _i0 < ${len($samples) + 1}; _i0++)
    _next_sample_flag[_i0] = false;
  
  /* Check if moment group needs sampling at the same time as another already discovered sample (or the final time).
   * If so, add this moment group to the to-be-sampled list. If moment group demands sampling earlier than all
   * previously noted moment groups, erase all previous ones from list and set the sample time to this earlier one.
   */
  @for $momentGroupNumber, $sampleCount in enumerate($samples)
    @if $sampleCount == 0
      @continue
    @end if
  if (_next_sample_counter[$momentGroupNumber] * _previous_M == _previous_m * $sampleCount) {
    _momentGroupNumbersNeedingSamplingNext[_numberOfMomentGroupsToBeSampledNext] = $momentGroupNumber;
    _numberOfMomentGroupsToBeSampledNext++;
  } else if (_next_sample_counter[$momentGroupNumber] * _previous_M < _previous_m * $sampleCount) {
    _${propagationDimension}_break_next = _next_sample_counter[$momentGroupNumber] * ((double)$interval) / ((double)$sampleCount);
    _numberOfMomentGroupsToBeSampledNext = 1;
    _momentGroupNumbersNeedingSamplingNext[0] = $momentGroupNumber;
    _previous_M = $sampleCount;
    _previous_m = _next_sample_counter[$momentGroupNumber];
  }
  
  @end for
  // _momentGroupNumbersNeedingSamplingNext now contains the complete list of moment groups that need
  // to be sampled at the next sampling point. Set their flags to true.
  for (long _i0 = 0; _i0 < _numberOfMomentGroupsToBeSampledNext; _i0++)
    _next_sample_flag[_momentGroupNumbersNeedingSamplingNext[_i0]] = true;
  
  return _${propagationDimension}_break_next;
}
  @#
@end def


@def timestepErrorFunctionImplementation($vector)
  @#
double _segment${segmentNumber}_${vector.id}_timestep_error(${vector.type}* _checkfield)
{
  double _error = 1e-24;
  double _temp_error = 0.0;
  double _temp_mod = 0.0;
  
  @set $featureOrdering = ['Diagnostics']
  @set $dict = {'vector': vector}
  ${insertCodeForFeatures('timestepErrorBegin', featureOrdering, {'vector': vector}), autoIndent=True}@slurp
  
  @if len($vector.field.dimensions) > 0
    @# FIXME: We need to have the capacity to have both a peak cutoff and an absolute cutoff
  // Find the peak value for each component of the field
  double _cutoff[_${vector.id}_ncomponents];
  
  for (long _i0 = 0; _i0 < _${vector.id}_ncomponents; _i0++)
    _cutoff[_i0] = 0.0;
  
  {
    ${loopOverVectorsInSpaceWithInnerContent([vector], $homeSpace, $insideFindPeakLoops(vector)), autoIndent=True}@slurp
  }
  ${insertCodeForFeatures('findMax', ['Driver'], {'variable': '_cutoff', 'count': c'_${vector.id}_ncomponents'}), autoIndent=True}@slurp
  
  for (long _i0 = 0; _i0 < _${vector.id}_ncomponents; _i0++) {
    if (!isfinite(_cutoff[_i0]))
      // Return an error two times the tolerance in this case because the timestep must be reduced.
      return 2.0*${tolerance};
    _cutoff[_i0] *= ${cutoff};
    @if $vector.type == 'complex'
      @# multiply again because we are using mod2 for our complex vector and the cutoff should be interpreted in terms of
      @# the absolute magnitude of the variables, not the mod-square
    _cutoff[_i0] *= ${cutoff};
    @end if
  }
  @end if
  
  @# Code for absolute cutoff should go here and modify
  @# the _cutoff variables
  @#
  @# @for $absoluteCutoff in $absoluteCutoffs
  @# // absolute cutoff for component '$absoluteCutoff.name'
  @# if (_cutoff[${absoluteCutoff.componentIndex}])
  @# @end for
  @#
  {
    ${loopOverFieldInSpaceWithVectorsAndInnerContent(vector.field, $homeSpace, [vector], $insideFindMaxErrorLoops(vector)), autoIndent=True}@slurp
  }
  ${insertCodeForFeatures('findMax', ['Driver'], {'variable': '&_error', 'count': '1'}), autoIndent=True}@slurp
  ${insertCodeForFeaturesInReverseOrder('timestepErrorEnd', featureOrdering, dict), autoIndent=True}@slurp
  
  return _error;
}
  @#
@end def


@def insideFindPeakLoops($vector)
  @#
for (long _i1 = 0; _i1 < _${vector.id}_ncomponents; _i1++) {
  @if $vector.type == 'complex'
    @set $modFunction = 'mod2'
  @else
    @set $modFunction = 'fabs'
  @end if
  _temp_mod = ${modFunction}(_${vector.id}[_${vector.id}_index_pointer + _i1]);
  if (!isfinite(_temp_mod))
    _cutoff[_i1] = INFINITY;
  else if (_cutoff[_i1] < _temp_mod)
    _cutoff[_i1] = _temp_mod;
}
  @#
@end def


@def insideFindMaxErrorLoops($vector)
  @#
for (long  _i1 = 0; _i1 < _${vector.id}_ncomponents; _i1++) {
  @if $vector.type == 'complex'
    @set $modCutoffFunction = 'mod2'
  @else
    @set $modCutoffFunction = 'fabs'
  @end if
  @if len($vector.field.dimensions) > 0
  if (${modCutoffFunction}(_${vector.id}[_${vector.id}_index_pointer + _i1]) > _cutoff[_i1]) {
    ${updateMaximumError($vector), autoIndent=True}@slurp
  }
  @else
  ${updateMaximumError($vector), autoIndent=True}@slurp
  @end if
}
  @#
@end def


@def updateMaximumError($vector)
  @#
  @if $vector.type == 'complex'
    @set $modErrorFunction  = 'mod'
  @else
    @set $modErrorFunction  = 'fabs'
  @end if
_temp_error = ${modErrorFunction}(_${vector.id}[_${vector.id}_index_pointer + _i1] - _checkfield[_${vector.id}_index_pointer + _i1]) / (0.5*${modErrorFunction}(_${vector.id}[_${vector.id}_index_pointer + _i1]) + 0.5*${modErrorFunction}(_checkfield[_${vector.id}_index_pointer + _i1]));

if (_error < _temp_error)
  _error = _temp_error;
  @#
${insertCodeForFeatures('updateMaximumError', ['Diagnostics'], {'vector': vector})}@slurp
  @#
@end def


@def resetFunctionImplementation($vector)
  @#
void _segment${segmentNumber}_${vector.id}_reset(${vector.type}* _reset_to)
{
  ${loopOverVectorsWithInnerContentTemplate([$vector], "_${vector.id}[$index] = _reset_to[$index];"), autoIndent=True}@slurp
}
  @#
@end def

@def createToleranceVariable
@*doc:
This function returns the code that will create a _step variable,
including any modifications necessary due to the ErrorCheck feature.
*@
  @#
double _tolerance = ${tolerance};
  @#
  @set $featureOrdering = ['ErrorCheck']
${insertCodeForFeatures('createToleranceVariable', featureOrdering)}@slurp
  @#
@end def

@def segmentFunctionBody($function)
  @#
double _step = ${interval}/(double)${stepCount};
double _old_step = _step;
double _min_step = _step;
double _max_step = _step;
long _attempted_steps = 0;
long _unsuccessful_steps = 0;

${createToleranceVariable}@slurp
  @# Insert code for features
  @set $featureOrderingOuter = ['Stochastic']
${insertCodeForFeatures('integrateAdaptiveStepBegin', featureOrderingOuter)}@slurp

double _error, _last_norm_error = 1.0;
  @for $vector in $integrationVectors
double _${name}_${vector.id}_error;
  @end for

bool _discard = false;
bool _break_next = false;

  @set $momentGroupCount = len($momentGroups)
bool _next_sample_flag[${momentGroupCount + 2}];
for (long _i0 = 0; _i0 < ${momentGroupCount + 2}; _i0++)
  _next_sample_flag[_i0] = false;

long _next_sample_counter[$momentGroupCount];
for (long _i0 = 0; _i0 < $momentGroupCount; _i0++)
  _next_sample_counter[_i0] = 1;

const double _${propagationDimension}_ini = ${propagationDimension};

double _${propagationDimension}_break_next = _${name}_setup_sampling(_next_sample_flag, _next_sample_counter);

if ( $propagationDimension - _${propagationDimension}_ini + _step >= _${propagationDimension}_break_next) {
  _break_next = true;
  _step = _${propagationDimension}_break_next - ${propagationDimension} + _${propagationDimension}_ini;
}

${allocate}@slurp
${initialise}@slurp
${localInitialise}@slurp

do {
  @set $featureOrderingOuterLoop = ['MaxIterations', 'Output', 'ErrorCheck']
  ${insertCodeForFeatures('integrateAdaptiveStepOuterLoopBegin', featureOrderingOuterLoop), autoIndent=True}@slurp
  
  ${preSingleStep, autoIndent=True}@slurp
  do {
  @# Insert code for features
  @set $featureOrderingInnerLoop = ['Stochastic']
    ${insertCodeForFeatures('integrateAdaptiveStepInnerLoopBegin', featureOrderingInnerLoop), autoIndent=True}@slurp
    
    ${stepper.singleIntegrationStep(function), autoIndent=True}@slurp
    
    ${insertCodeForFeaturesInReverseOrder('integrateAdaptiveStepInnerLoopEnd', featureOrderingInnerLoop), autoIndent=True}@slurp
    
    _error = 0.0;
  @for $vector in $integrationVectors
    
    _${name}_${vector.id}_error = _${name}_${vector.id}_timestep_error(_${stepper.errorFieldName}_${vector.id});
    if (_${name}_${vector.id}_error > _error)
      _error = _${name}_${vector.id}_error;
  @end for
    
    _attempted_steps++;
    
  @set $featureOrderingForToleranceChecking = ['Diagnostics', 'Stochastic']
    if (_error < _tolerance) {
      ${insertCodeForFeatures('adaptiveStepSucceeded', $featureOrderingForToleranceChecking), autoIndent=True}@slurp
      if (_step > _max_step)
        _max_step = _step;
      if (!_break_next && _step < _min_step)
        _min_step = _step;
      _discard = false;
    } else {
      ${insertCodeForFeatures('adaptiveStepFailed', $featureOrderingForToleranceChecking), autoIndent=True}@slurp
      t -= _step;
  @for $vector in $integrationVectors
      
      _${name}_${vector.id}_reset(_${stepper.resetFieldName}_${vector.id});
  @end for
      ${functions['ipEvolve'].call(_exponent = -1, parentFunction=function)}
      
      _discard = true;
      _break_next = false;
      _unsuccessful_steps++;
    }
    
    _old_step = _step;
    
    // Resize step
    if (_error < 0.5*_tolerance || _error > _tolerance) {
      double _scalingFactor = 0.92 * pow(fabs(_error/_tolerance), -0.7/${integrationOrder}) * pow(_last_norm_error, 0.4/${integrationOrder});
      _scalingFactor = MAX(_scalingFactor, 1.0/5.0);
      _scalingFactor = MIN(_scalingFactor, 7.0);
      if (_error > _tolerance && _scalingFactor > 1.0) {
        // If our step failed don't try and increase our step size. That would be silly.
        _scalingFactor = 0.92 * pow(fabs(_error/_tolerance), -1.0/${integrationOrder});
      }
      _old_step = _step;
      _last_norm_error = pow(0.92/_scalingFactor*pow(_last_norm_error, 0.4/${integrationOrder}), ${integrationOrder}/0.7);
      _step *= _scalingFactor;
    }
    
  } while (_discard);
  ${postSingleStep, autoIndent=True}@slurp
  
  ${insertCodeForFeaturesInReverseOrder('integrateAdaptiveStepOuterLoopEnd', featureOrderingOuterLoop), autoIndent=True}@slurp
} while (!_next_sample_flag[${momentGroupCount + 1}]);

${localFinalise}@slurp
${finalise}@slurp
${free}@slurp
  @#
${insertCodeForFeaturesInReverseOrder('integrateAdaptiveStepEnd', featureOrderingOuter)}@slurp

_LOG(_SEGMENT_LOG_LEVEL, "Segment ${segmentNumber}: minimum timestep: %e maximum timestep: %e\n", _min_step, _max_step);
_LOG(_SEGMENT_LOG_LEVEL, "  Attempted %li steps, %.2f%% steps failed.\n", _attempted_steps, (100.0*_unsuccessful_steps)/_attempted_steps);
  @#
@end def
