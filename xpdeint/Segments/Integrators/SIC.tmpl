@*
SIC.tmpl

Created by Graham Dennis on 2008-08-06.
Copyright (c) 2008 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Segments.Integrators._SIC

@def description: segment $segmentNumber (SI Integrator with integrated cross-propagation)
@attr $ipPropagationStepFractions = ['0.5']
@attr $nonconstantIPFields = 1
@attr $extraIntegrationArrayNames = ['oldcopy']
@attr $isCrossCapable = False
@attr $iterations = 3

@*
  Single integration step (SIC)
*@
@def singleIntegrationStep($function)
  @#
  @set $arguments = {'_step': '_step', $propagationDimension: $propagationDimension}
${functions['nonconstantIPFields'].call(arguments, _exponent = 1, _arrayIndex = 0, parentFunction=function)}

${functions['ipEvolve'].call(arguments, _exponent = +1, parentFunction=function)}

${propagationDimension} += 0.5*_step;

${transformVectorsToSpace($integrationVectors, $homeSpace)}@slurp

${copyVectors($integrationVectors, '_oldcopy')}@slurp

  @for $vector in $integrationVectors
_active_${vector.id} = _${vector.id};
  @end for

for (int _iteration = 0; _iteration < ${iterations}; _iteration++) {
  if (_iteration < ${iterations} - 1) {
  @if $leftOperatorContainer
    ${functions['leftDeltaA'].call(arguments, _step = '0.5*_step', parentFunction=function), autoIndent=True}
  @end if
  @if $rightOperatorContainer
    ${functions['rightDeltaA'].call(arguments, _step = '0.5*_step', parentFunction=function), autoIndent=True}
  @end if
  } else {
    ${functions['deltaA'].call(arguments, parentFunction=function), autoIndent=True}
    
    ${transformVectorsToSpace($integrationVectors, $homeSpace), autoIndent=True}@slurp
    
    ${loopOverVectorsWithInnerContentTemplate($integrationVectors,
"""// a = oldcopy + a
_${vector.id}[$index] += _oldcopy_${vector.id}[$index];
"""), autoIndent=True}@slurp
  }
  
}

${functions['ipEvolve'].call(arguments, _exponent = +1, parentFunction=function)}

${propagationDimension} += 0.5*_step;

  @#
@end def

@def leftRightDeltaAFunctionBody($function, $replacementOperatorContainer)
  @#
  @# First evaluate any computed vector that any of our operators may depend on
${evaluateComputedVectors($computedVectorsNeedingPrecalculationForOperatorContainers($intraStepOperatorContainers))}@slurp
  @#
  @# Then loop over operators that come before the delta A operators in the order in which
  @# they appear in the xmds script.
  @#
  @for $operatorContainer in $intraStepOperatorContainers

${operatorContainer.evaluatePreDeltaAOperators(parentFunction = function)}@slurp
  @end for
  @#
  @# Now loop over delta A operators
  @# See the comment in _Integrator about why this needs to be done in
  @# this particular order
  @for $operatorContainer in $intraStepOperatorContainersInFieldDescendingOrder
    @# Blank line for formatting

    @if not operatorContainer == $operatorContainerToOverride
${operatorContainer.evaluateDeltaAOperator(parentFunction = function)}@slurp
    @else
${replacementOperatorContainer.evaluateDeltaAOperator(parentFunction = function)}@slurp
    @end if
  @end for
  @#
  @# Lastly, loop over the operators that come after the delta a operators in the order in
  @# which they appear in the xmds script.
  @#
  @for $operatorContainer in $intraStepOperatorContainers
    @# Blank line for formatting

${operatorContainer.evaluatePostDeltaAOperators(parentFunction = function)}@slurp
  @end for
  @#

  @set $integrationVectorsNeedingUpdating = $integrationVectors
  @silent integrationVectorsNeedingUpdating.difference_update(replacementOperatorContainer.deltaAOperator.integrationVectors)
${transformVectorsToSpace($integrationVectorsNeedingUpdating, $homeSpace), autoIndent=True}@slurp

${loopOverVectorsWithInnerContentTemplate($integrationVectorsNeedingUpdating,
c"""// a = oldcopy + a
_\${vector.id}[\$index] += _${name}_oldcopy_\${vector.id}[\$index];
""")}@slurp
  @#
@end def

