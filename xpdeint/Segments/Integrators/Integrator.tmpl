@*
Integrator.tmpl

Created by Graham Dennis on 2007-10-20.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Segments.Integrators._Integrator
@from xpdeint.CallOnceGuards import callOncePerInstanceGuard

@def description: segment $segmentNumber (Unnamed Integrator)

@*
  Globals
*@
@def globals
  @#
  @super
  @#
  @for $vector in $integrationVectors
    @# Loop over the variables that need to be created
    @for $arrayName in $extraIntegrationArrayNames
${vector.type}* _${name}_${arrayName}_${vector.id};
    @end for
  @end for
  @#
@end def

@*
  Function prototypes
*@
@def functionPrototypes
  @#
  @super
  @#
void _segment${segmentNumber}();
inline void _segment${segmentNumber}_calculate_delta_a(double _step);
inline void _segment${segmentNumber}_ip_evolve(int _exponent);

  @#
@end def

@*
  Function implementations
*@
@def functionImplementations
  @#
  @super
  @#
${deltaAFunctionImplementation}@slurp

  @#
${ipEvolveFunctionImplementation}@slurp
  @#

${segmentFunctionImplementation}@slurp
  @#

  @#
@end def

@def ipEvolveFunctionImplementation
  @#
inline void _segment${segmentNumber}_ip_evolve(int _exponent)
{
  @set $blankLineSeparator = ''
  @#
  @for $operatorContainer in $operatorContainers
${blankLineSeparator}@slurp
  ${operatorContainer.evaluateIPOperators(arguments = {'_exponent': '_exponent'}), autoIndent=True}@slurp
    @set $blankLineSeparator = '\n'
  @end for
  @#  
}
  @#
@end def

@def deltaAFunctionImplementation
  @#
inline void _segment${segmentNumber}_calculate_delta_a(double _step)
{
  @# First evaluate any computed vector that any of our operators may depend on
  @set allDependencies = $operatorDependenciesForOperatorContainers($intraStepOperatorContainers)
  ${evaluateComputedVectors($allDependencies), autoIndent=True}@slurp
  @#
  @# Then loop over operators that come before the delta A operators in the order in which
  @# they appear in the xmds script.
  @#
  @for $operatorContainer in $intraStepOperatorContainers
  
  ${operatorContainer.evaluatePreDeltaAOperators(arguments = {'_step': '_step'}), autoIndent=True}@slurp
  @end for
  @#
  @# Now loop over delta A operators
  @# See the comment in _Integrator about why this needs to be done in
  @# this particular order
  @for $operatorContainer in $intraStepOperatorContainersInFieldDescendingOrder
    @# Blank line for formatting
  
  ${operatorContainer.evaluateDeltaAOperator(arguments = {'_step': '_step'}), autoIndent=True}@slurp
  @end for
  @#
  @# Lastly, loop over the operators that come after the delta a operators in the order in
  @# which they appear in the xmds script.
  @#
  @for $operatorContainer in $intraStepOperatorContainers
    @set $result = $operatorContainer.evaluatePostDeltaAOperators(arguments = {'_step': '_step'})
    @if not result.isspace()
    @# Blank line for formatting
  
  ${result, autoIndent=True}@slurp
    @end if
  @end for
}
  @#
@end def

@def preSingleStep
  @#
  @set allDependencies = $operatorDependenciesForOperatorContainers($stepStartOperatorContainers)
${evaluateComputedVectors($allDependencies)}@slurp
  @#
  @for $operatorContainer in $stepStartOperatorContainers
  
${operatorContainer.evaluateOperators}@slurp
  @end for
  @#
@end def

@def postSingleStep
  @#
  @set allDependencies = $operatorDependenciesForOperatorContainers($stepEndOperatorContainers)
${evaluateComputedVectors($allDependencies)}@slurp
  @#
  @for $operatorContainer in $stepEndOperatorContainers
  
${operatorContainer.evaluateOperators}@slurp
  @end for
  @#
@end def


@@callOncePerInstanceGuard
@def initialise
@*doc:
Allocate additional arrays needed for the integrator

This is a call once-per-instance function because we may want to do the initialisation
(and clean-up) for this segment in a parent segment for efficiency reasons (if, for
example we are looping over this segment, or we are running multiple paths).
*@
  @# Loop over the vectors creating the arrays
  @for $vector in $integrationVectors
    @# Loop over the variables that need to be created
    @for $arrayName in $extraIntegrationArrayNames
_${name}_${arrayName}_${vector.id} = @slurp
(${vector.type}*) xmds_malloc(sizeof(${vector.type}) * _${vector.field.name}_alloc_size * _${vector.id}_ncomponents);
    @end for
  @end for
  @#
  @# Loop over the computed vectors, as we need to allocate their arrays
  @for $vector in $computedVectors
$vector.allocate@slurp
  @end for
  @#
  @# Let the operators allocate and initialise any arrays they need
  @for $operatorContainer in $operatorContainers
$operatorContainer.initialise@slurp
  @end for
  @#
@end def

@@callOncePerInstanceGuard
@def finalise
  @#
  @for $vector in $integrationVectors
    @for $arrayName in $extraIntegrationArrayNames
xmds_free(_${name}_${arrayName}_${vector.id});
    @end for
  @end for
  @#
  @# Loop over the computed vectors, as we need to clean up their arrays
  @for $vector in $computedVectors
$vector.free@slurp
  @end for
  @#
  @# Let the operators do their clean up
  @for $operatorContainer in $operatorContainers
$operatorContainer.finalise@slurp
  @end for
  @#
@end def

@def localInitialise
@*doc:
Because the initialisation for the integrator could be in a different function,
we need to set up pointers in the integrator to the appropriate arrays.
*@
  @#
  @for $vector in $integrationVectors
    @# Loop over the variables that need to be created
    @for $arrayName in $extraIntegrationArrayNames
${vector.type}* _${arrayName}_${vector.id} = _${name}_${arrayName}_${vector.id};
    @end for
  @end for  
  @#
@end def

@def goToHomeSpace
@*doc:
This method writes the code to transform all of the integration vectors
back to the 'home space' of the integrator.
*@
${transformVectorsToSpace($integrationVectors, $homeSpace)}@slurp
  @#
@end def
