@*
Integrator.tmpl

Created by Graham Dennis on 2007-10-20.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Segments.Integrators._Integrator
@from xpdeint.CallOnceGuards import callOncePerInstanceGuard

@def description: segment $segmentNumber (Unnamed Integrator)

@*
  Globals
*@
@def globals
  @#
  @super
  @#
  @for $vector in $integrationVectors
    @# Loop over the variables that need to be created
    @for $arrayName in $extraIntegrationArrayNames
${vector.type}* _${name}_${arrayName}_${vector.id};
    @end for
  @end for
  @#
@end def

@def deltaAFunctionBody($function)
  @#
  @# First evaluate any computed vector that any of our operators may depend on
${evaluateComputedVectors($computedVectorsNeedingPrecalculationForOperatorContainers($intraStepOperatorContainers))}@slurp
  @#
  @# Then loop over operators that come before the delta A operators in the order in which
  @# they appear in the xmds script.
  @#
  @for $operatorContainer in $intraStepOperatorContainers

${operatorContainer.evaluatePreDeltaAOperators(parentFunction = function)}@slurp
  @end for
  @#
  @# Now loop over delta A operators
  @# See the comment in _Integrator about why this needs to be done in
  @# this particular order
  @for $operatorContainer in $intraStepOperatorContainersInFieldDescendingOrder
    @# Blank line for formatting

${operatorContainer.evaluateDeltaAOperator(parentFunction = function)}@slurp
  @end for
  @#
  @# Lastly, loop over the operators that come after the delta a operators in the order in
  @# which they appear in the xmds script.
  @#
  @for $operatorContainer in $intraStepOperatorContainers
    @# Blank line for formatting

${operatorContainer.evaluatePostDeltaAOperators(parentFunction = function)}@slurp
  @end for
  @#
@end def

@def preSingleStep
  @#
${evaluateComputedVectors($computedVectorsNeedingPrecalculationForOperatorContainers($stepStartOperatorContainers))}@slurp
  @#
  @for $operatorContainer in $stepStartOperatorContainers

${operatorContainer.evaluateOperators}@slurp
  @end for
  @#
@end def

@def postSingleStep
  @#
  @set $featureOrdering = ['HaltNonFinite']
  @#
${insertCodeForFeatures('postSingleStep', featureOrdering)}@slurp
  @#
${evaluateComputedVectors($computedVectorsNeedingPrecalculationForOperatorContainers($stepEndOperatorContainers))}@slurp
  @#
  @for $operatorContainer in $stepEndOperatorContainers

${operatorContainer.evaluateOperators}@slurp
  @end for
  @#
@end def

@@callOncePerInstanceGuard
@def initialise
@*doc:
Allocate additional arrays needed for the integrator

This is a call once-per-instance function because we may want to do the initialisation
(and clean-up) for this segment in a parent segment for efficiency reasons (if, for
example we are looping over this segment, or we are running multiple paths).
*@
  @# Loop over the vectors creating the arrays
  @for $vector in $integrationVectors
    @# Loop over the variables that need to be created
    @for $arrayName in $extraIntegrationArrayNames
_${name}_${arrayName}_${vector.id} = @slurp
(${vector.type}*) xmds_malloc(sizeof(${vector.type}) * ${allocSizeOfVector(vector)});
    @end for
  @end for
  @#
  @# Loop over the computed vectors, as we need to allocate their arrays
  @for $vector in $computedVectors
$vector.allocate@slurp
  @end for
  @#
  @# Let the operators allocate and initialise any arrays they need
  @for $operatorContainer in $operatorContainers
$operatorContainer.initialise@slurp
  @end for
  @#
@end def

@@callOncePerInstanceGuard
@def finalise
  @#
  @for $vector in $integrationVectors
    @for $arrayName in $extraIntegrationArrayNames
xmds_free(_${name}_${arrayName}_${vector.id});
    @end for
  @end for
  @#
  @# Loop over the computed vectors, as we need to clean up their arrays
  @for $vector in $computedVectors
$vector.free@slurp
  @end for
  @#
  @# Let the operators do their clean up
  @for $operatorContainer in $operatorContainers
$operatorContainer.finalise@slurp
  @end for
  @#
@end def

@def localInitialise
@*doc:
Because the initialisation for the integrator could be in a different function,
we need to set up pointers in the integrator to the appropriate arrays.
*@
  @#
  @for $vector in $integrationVectors
    @# Loop over the variables that need to be created
    @for $arrayName in $extraIntegrationArrayNames
${vector.type}* _${arrayName}_${vector.id} = _${name}_${arrayName}_${vector.id};
    @end for
  @end for  
  @#
@end def

@def localFinalise
@*doc:
Because the finalisation for the integrator could be in a different function,
we need to be able to insert code at the end of the integrator as well.
*@
  @#
_SEGMENT${segmentNumber}_END:;
  @#
@end def

@def goToHomeSpace
@*doc:
This method writes the code to transform all of the integration vectors
back to the 'home space' of the integrator.
*@
${transformVectorsToSpace($integrationVectors, $homeSpace)}@slurp
  @#
@end def

@def earlyTerminationCode
@*doc:
This method writes code that should be executed if the integrator needs
to be terminated early
*@
  @#
  @for mg, sampleCount in zip($momentGroups, $samples)
    @if not $sampleCount
      @continue
    @end if
    @#
    @for dim in mg.dimensionOverrides
if (_${mg.name}_sample_index_${dim.name} < _${mg.outputField.name}_lattice_${dim.name})
  _${mg.name}_sample();
    @end for
  @end for

goto _SEGMENT${segmentNumber}_END;
  @#
@end def
