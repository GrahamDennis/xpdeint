@*
BreakpointSegment.tmpl

Created by Graham Dennis on 2008-03-15.
Copyright (c) 2008 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Segments._BreakpointSegment
@from xpdeint.CallOnceGuards import callOnceGuard

@*
  Description of template
*@
@def description: segment $segmentNumber (Breakpoint)

@*
  Static globals
*@
@@callOnceGuard
@def static_globals
  @#
  @super
  @#
long _breakpointAutoNameCounter = 0;
  @#
@end def

@*
  Function prototypes
*@
@def functionPrototypes
  @#
  @super
  @#
void _segment${segmentNumber}();
  @#
@end def

@*
  Function implementations
*@
@def functionImplementations
  @#
  @super
  @#

void _segment${segmentNumber}()
{
  ${evaluateComputedVectors($dependencies), autoIndent=True}@slurp
  
  ${transformVectorsToSpace($dependencies, $breakpointSpace), autoIndent=True}@slurp
  
  @set $featureOrdering = ['Driver']
  @set $dict = {'extraIndent': 0}
  ${insertCodeForFeatures('breakpointBegin', featureOrdering, dict), autoIndent=True}@slurp
  @set $extraIndent = dict['extraIndent']
  
  ${breakpointFunctionContents, autoIndent=True, extraIndent=extraIndent}@slurp
  
  ${insertCodeForFeaturesInReverseOrder('breakpointEnd', $featureOrdering, dict), autoIndent=True}@slurp
}

  @#
@end def

@def breakpointFunctionContents
  @#
  @if not $filename
    @# If we don't have a filename, then we are auto-naming
_breakpointAutoNameCounter++;
char *_baseFilename = (char*)malloc(100);
snprintf(_baseFilename, 100, "%li", _breakpointAutoNameCounter);
  @else
    @# We have a name, rip off the extension if its 'xsil'
    @set baseFilename = $filename
    @if baseFilename.endswith('.xsil')
      @set baseFilename = baseFilename[0:-5]
    @end if
const char *_baseFilename = "$baseFilename";
  @end if
  
char *_xsilFilename = (char*)malloc(200);
char *_datFilename  = (char*)malloc(200);
strncpy(_xsilFilename, _baseFilename, 200);
strncpy(_datFilename, _baseFilename, 200);
strcat(_xsilFilename, ".xsil");
strcat(_datFilename, ".dat");

  @set featureOrdering = ['Output']
FILE *_outfile = _write_xsil_header(_xsilFilename);

  @set $dependentVariables = [{'vector': vector, 'arrayName': c'_active_${vector.id}', 'components': vector.components} for vector in $dependencies]
  @set $writeOutDict = {'field': $field,
                        'space': $breakpointSpace,
                        'fp': '_outfile',
                        'datFilename': "_datFilename",
                        'dependentVariables': dependentVariables,
                        'xsilElementName': "breakpoint",
                       }
  @set $featureOrdering = ['Output']
${insertCodeForFeatures('writeOutFunctionImplementationBody', $featureOrdering, $writeOutDict)}@slurp

_write_xsil_footer(_outfile);

  @#
@end def

