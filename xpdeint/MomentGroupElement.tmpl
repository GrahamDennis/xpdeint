@*
MomentGroupElement.tmpl

Created by Graham Dennis on 2007-09-05.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint._MomentGroupElement
@*

  Description of template
*@
@def description: moment group $number


@*
  Implementation of the moment group sample function
*@
@def sampleFunctionContents($function)
  @# Evaluate any computed vectors we have that either we or one
  @# of our operators depends on
  @set $computedVectorDependencies = $dependencies.copy()
  @silent computedVectorDependencies.update($computedVectorsNeedingPrecalculationForOperatorContainers($operatorContainers))
${evaluateComputedVectors(computedVectorDependencies)}@slurp
  @#
  @# Execute any operatorContainers
  @for $operatorContainer in $operatorContainers

${operatorContainer.evaluateOperators(parentFunction=function)}@slurp
  @end for

  @# Now we need to loop over the vector dependencies going the the appropriate space.
${transformVectorsToSpace($dependencies, $sampleSpace)}@slurp
  @#
  @# Set up the index overrides
  @set $indexOverrides = {}
  @silent indexOverrides[$propagationDimension] = { $outputField: c'_${outputField.id}_index_${propagationDimension}'}
  @#
  @set $vectorsForLoop = $dependencies.copy()
  @silent $vectorsForLoop.add($rawVector)
  @# Now actually begin the loop

${loopOverFieldInSpaceWithVectorsAndInnerContent($samplingField, $sampleSpace, $vectorsForLoop, $insideSamplingLoops, indexOverrides=indexOverrides, vectorOverrides=[$rawVector])}@slurp
  @# That's the end of the loop, magic eh?
  @#
  @if $outputField.hasDimensionName($propagationDimension)

_${outputField.id}_${propagationDimension}[_${outputField.id}_index_${propagationDimension}++] = $propagationDimension;
  @end if

_LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #${number + 1}) at ${propagationDimension} = %e\n", ${propagationDimension});
  @#
@end def

@*
  This function provides the contents of the moment group sampling loop
*@
@def insideSamplingLoops
  @#
#define _SAMPLE_COMPLEX(variable) \
          variable ## R = variable.re; variable ## I = variable.im;

// *************** Sampling code ****************
${insertUserCodeFromEntity($samplingCodeEntity)}@slurp
// **********************************************

#undef _SAMPLE_COMPLEX
  @#
@end def

@*
  Process function implementation
*@
@def processFunctionContents($function)
  @# If we don't have any processing code then we don't need to do a complicated loop
  @if not self.hasattr('processingCode')
    @# If we didn't allocate a raw vector, then there actually is no processing to do
    @# at all.
    @if not $rawVectorNeedsToBeAllocated
// No post processing needs to be done
    @else
      @#
      @# Although we don't have any processing code, one of our features has
      @# processing code that needs to run (but it is simple, right?)
${loopOverVectorsWithInnerContentTemplate($outputField.vectors, $insideProcessingLoopsNoProcessingCode)}@slurp
    @end if
  @else
    @# In this case, we did allocate a raw vector, and we will have processing to do
    @# Transform the moment group sampling vector into the processing space
${transformVectorsToSpace($vectors, $processingSpace)}@slurp
    @#
    @if len($outputField.dimensions) != len($dimensions)
      @# If the output field doesn't have the same number of dimensions as the sampled
      @# data, then we're going to be integrating, and the vectors in the output field
      @# are going to need to be overridden in the loop
      @assert len($outputField.dimensions) < len($dimensions)
      @set $vectorOverrides = $outputField.vectors.copy()
    @else
      @set $vectorOverrides = set()
    @end if
    @set $vectorsForLoop = $vectors.copy()
    @silent $vectorsForLoop.update($outputField.vectors)
${loopOverFieldInSpaceWithVectorsAndInnerContent($self, $processingSpace, $vectorsForLoop, $insideProcessingLoops, vectorOverrides=$vectorOverrides)}@slurp
  @end if
  @#
@end def

@def insideProcessingLoopsNoProcessingCode
  @#
_active_${processedVector.id}[\${index}] += _active_\${vector.id}[\${index}];
  @set $featureOrdering = ['Driver']
${insertCodeForFeatures('insideMomentGroupProcessingNoProcessingCodeLoop', $featureOrdering)}
  @#
@end def

@*
  This function provides the contents of the moment group processing loop
*@
@def insideProcessingLoops
  @#
// ************** Processing code ***************
${processingCode, fixupWhitespace=True}
// **********************************************

  @set $featureOrdering = ['Driver']
$insertCodeForFeatures('insideMomentGroupProcessingLoop', $featureOrdering)@slurp
  @#
@end def

@*
  Write output function implementation
*@
@def writeOutFunctionContents($function)
  @#
  @set $outputFieldVectorComponents = $anyObject($outputField.vectors).components
  @set $dependentVariables = [{'vector': $processedVector,
                               'arrayName': c'_active_${processedVector.id}',
                               'components': $processedVector.components}]
  @#
  @# Note that Driver must be last
  @set $featureOrdering = ['ErrorCheck', 'Driver']
  @set $dict = {'momentGroup': self, 'dependentVariables': $dependentVariables}
  @set $result = $insertCodeForFeatures('writeOutFunctionImplementationBegin', $featureOrdering, $dict)
  @set $dependentVariables = $dict.dependentVariables
  @set $componentCount = 0
  @for $variable in $dependentVariables
    @set $componentCount += len($variable.vector.components)
    @# Technically, all these variables must be of type double...
    @if $variable.vector.type == 'complex'
      @set $componentCount += len($variable.vector.components)
    @end if
  @end for
  @#
  @# The features can return Cheetah template code suitable for passing to loopOverVectorsWithInnerContentTemplate
  @# in order to create their data. If any have, then we should actually create that loop and run that code.
  @if $result
${loopOverVectorsWithInnerContentTemplate([$processedVector], $result)}@slurp
  @end if

// The meat of the function goes here
  @set $featureOrdering = ['Output']
  @set $dict = {'field': $outputField,
                'space': $outputSpace,
                'fp': '_outfile',
                'dependentVariables': $dependentVariables,
                'xsilElementName': c'moment_group_${number + 1}',
                }
${insertCodeForFeatures('writeOutFunctionImplementationBody', $featureOrdering, $dict)}@slurp
  @#
@end def


@*
  Allocate (and initialise active pointers) (called from main)
*@
@def allocate
  @# We actually only want to allocate this vector (we should only have one)
  @# if rawVectorNeedsToBeAllocated is True
  @assert len($managedVectors) == 1
  @assert $anyObject($managedVectors).name == 'raw'
  @#
  @if $rawVectorNeedsToBeAllocated
    @# Call the superclass to allocate the vector
    @super
  @end if
  @#
  @for vector in $computedVectors
${vector.allocate}@slurp
  @end for
  @#
  @for operatorContainer in $operatorContainers
${operatorContainer.initialise}@slurp
  @end for
  @#
@end def

@*
  Free
*@
@def free
  @#
  @assert len($managedVectors) == 1
  @assert $anyObject($managedVectors).name == 'raw'
  @#
  @if $rawVectorNeedsToBeAllocated
    @# Call the superclass to free the vector
    @super
  @end if
  @#
  @for vector in $computedVectors
${vector.free}@slurp
  @end for
  @#
  @for operatorContainer in $operatorContainers
${operatorContainer.finalise}@slurp
  @end for
  @#
@end def
