@*
BinaryOutput.tmpl

Created by Graham Dennis on 2007-09-20.
Copyright (c) 2007-2008 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Features.OutputFeature
@from xpdeint.Geometry.NonUniformDimensionRepresentation import NonUniformDimensionRepresentation

@def description: binary output

@def writeOutFunctionImplementationBody($dict)
  @#
${writeOutFunctionImplementationBegin(dict)}@slurp

  @if not 'datFilename' in dict:
    @set caller = dict['caller']
    @set dict['datFilename'] = c'"${filename}_${caller.name}.dat"'
  @end if
  @#
  @set $featureOrdering = ['Driver']
  @set $featureDict = dict.copy()
  @set $featureDict['extraIndent'] = 0
${insertCodeForFeatures('binaryWriteOutBegin', featureOrdering, featureDict)}@slurp
  @set $extraIndent = featureDict['extraIndent']

${writeOutFunctionContents(dict), extraIndent=extraIndent}@slurp

${insertCodeForFeaturesInReverseOrder('binaryWriteOutEnd', featureOrdering, featureDict)}@slurp

${writeOutFunctionImplementationEnd(dict)}@slurp
  @#
@end def

@def writeOutFunctionContents($dict)
  @#
  @set $fp = dict['fp']
  @set $datFilename = dict['datFilename']
  @set $field = dict['field']
  @set $space = dict['space']
  @set $dependentVariables = dict['dependentVariables']
  @set $componentCount = 0
  @for $variable in $dependentVariables
    @set $componentCount += len($variable.vector.components)
    @if $variable.vector.type == 'complex'
      @set $componentCount += len($variable.vector.components)
    @end if
  @end for
  @set dict['componentCount'] = componentCount
  @#
const char *encoding = NULL;
#if CFG_ENDIAN == CFG_ENDIAN_BIG
  encoding = "BigEndian";
#else
  encoding = "LittleEndian";
#endif

const char *unsignedLongType = NULL;
if (sizeof(unsigned long) == 4)
  unsignedLongType = "uint32";
else if (sizeof(unsigned long) == 8)
  unsignedLongType = "uint64";
else
  unsignedLongType = "ulong";

fprintf($fp, "    <Stream><Metalink Format=\"Binary\" UnsignedLong=\"%s\" precision=\"double\" Type=\"Remote\" Encoding=\"%s\"/>\n",
        unsignedLongType, encoding);
fprintf($fp, "%s\n", ${datFilename});

FILE* fpBinary;
if ((fpBinary = fopen(${datFilename}, "wb")) == NULL)
  // _LOG will cause the simulation to exit
  _LOG(_ERROR_LOG_LEVEL, "Unable top open output file %s\n"
                         "Chucking a spack...\n", ${datFilename});

unsigned long dataSize;
off_t fieldOffset = 0;
double coordinate;

  @for $dim in $field.dimensions
    @set $dimRep = $dim.inSpace(space)
dataSize = ${dimRep.globalLattice};
fwrite(&dataSize, sizeof(unsigned long), 1, fpBinary);
    @if isinstance(dimRep, NonUniformDimensionRepresentation)
fwrite(${dimRep.arrayName}, sizeof(double), dataSize, fpBinary);
    @else
coordinate = ${dimRep.minimum};
for (long _i0 = 0; _i0 < dataSize; _i0++, coordinate += ${dimRep.stepSize})
  fwrite(&coordinate, sizeof(double), 1, fpBinary);
    @end if
fieldOffset += sizeof(unsigned long) + sizeof(double) * dataSize;

  @end for
off_t vectorFieldSize = _${field.name}_size * sizeof(double) + sizeof(unsigned long);
dataSize = _${field.name}_size;

for (int _i = 0; _i < ${componentCount}; _i++) {
  fseeko(fpBinary, fieldOffset + _i * vectorFieldSize, SEEK_SET);
  fwrite(&dataSize, sizeof(unsigned long), 1, fpBinary);
}

  @# This is where all of the magic MPI code goes
  @set $featureOrdering = ['Driver']
  @set $featureDict = dict.copy()
  @set $featureDict['extraIndent'] = 0
${insertCodeForFeatures('binaryWriteOutWriteDataBegin', $featureOrdering, featureDict)}@slurp
  @set $extraIndent = featureDict['extraIndent']

${writeData(dict), extraIndent=extraIndent}@slurp

  @# This is where the rest of the magic MPI code goes
${insertCodeForFeaturesInReverseOrder('binaryWriteOutWriteDataEnd', $featureOrdering, featureDict)}@slurp

fclose(fpBinary);
fprintf($fp, "    </Stream>\n");
  @#
@end def


@def writeData($dict)
  @#
  @set $field = dict['field']
  @set $space = dict['space']
  @set $dependentVariables = dict['dependentVariables']
  @#
  @set variablesInEarlierVectors = 0
  @for $variable in $dependentVariables
    @set $componentNameSizePrefix = ''
    @if $variable.vector.type == 'complex'
      @set $componentNameSizePrefix = '2 * '
    @end if
// loop over components of vector '${variable.vector.id}' (array '${variable.arrayName}')
for (unsigned int _component = 0; _component < ${componentNameSizePrefix}_${variable.vector.id}_ncomponents; _component++) {
  off_t _outputfield_index_pointer, _outputfield_old_index_pointer;
  _outputfield_index_pointer = -42; // Just so that we always seek the first time

    @set $innerContent = $innerLoopsForVariable($variable, variablesInEarlierVectors, dict)
    @set $vectors = [$variable.vector]
  ${loopOverFieldInSpaceWithVectorsAndInnerContent($field, $space, $vectors, $innerContent, vectorsNotNeedingDefines=vectors), autoIndent=True}@slurp
} // end loop over components of vector '${variable.vector.id}' (array '${variable.arrayName}')
    @set $variablesInEarlierVectors += $variable.vector.nComponents
    @if $variable.vector.type == 'complex'
      @set $variablesInEarlierVectors += $variable.vector.nComponents
    @end if
  @end for

  @#
@end def

@def innerLoopsForVariable($variable, $variablesInEarlierVectors, $dict)
  @#
  @set $field = dict['field']
  @set $space = dict['space']
  @#
_outputfield_old_index_pointer = _outputfield_index_pointer;
_outputfield_index_pointer = 0;

// Calculate the output field index pointer
  @for $dim in $field.dimensions
_outputfield_index_pointer += ($dim.inSpace(space).strictlyAscendingGlobalIndex)@slurp
 * ${field.pointsInDimensionsWithIndices(range(field.indexOfDimension(dim)+1, len(field.dimensions)))};
  @end for

if (_outputfield_index_pointer != _outputfield_old_index_pointer + 1)
  fseeko(fpBinary, fieldOffset + _outputfield_index_pointer * sizeof(double) + (${variablesInEarlierVectors} + _component) * vectorFieldSize + sizeof(unsigned long), SEEK_SET);

  @if $variable.vector.type == 'double'
fwrite(&${variable.arrayName}[_${variable.vector.id}_index_pointer + _component], sizeof(double), 1, fpBinary);
  @else
if (_component & 1)
  fwrite(&${variable.arrayName}[_${variable.vector.id}_index_pointer + _component/2].im, sizeof(double), 1, fpBinary);
else
  fwrite(&${variable.arrayName}[_${variable.vector.id}_index_pointer + _component/2].re, sizeof(double), 1, fpBinary);
  @end if
  @#
@end def



