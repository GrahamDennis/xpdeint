@*
Stochastic.tmpl

Created by Graham Dennis on 2007-12-11.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Features._Stochastic

@from xpdeint.Operators.DeltaAOperator import DeltaAOperator

@def description: Stochastic
@attr featureName = 'Stochastic'

@*
  Globals
*@
@def globals
  @#
  @super
  @#
  @set $noisesNeeded = filter(lambda x: x.noiseDistribution in ('gaussian', 'poissonian'), $noises)
// ********************************************************
// struct used to store step size and noise vector to ensure
// stochastic convergence
struct _dtdWstore {
  real _step;
  @for noise in noisesNeeded
    @for noiseVector in noise.noiseVectors.itervalues()
  real* _${noiseVector.id};
    @end for
  @end for
  _dtdWstore() {
    _step = 0;
  @for noise in noisesNeeded
    @for noiseVector in noise.noiseVectors.itervalues()
    _${noiseVector.id} = NULL;
    @end for
  @end for
  }
  ~_dtdWstore() {
  @for noise in noisesNeeded
    @for noiseVector in noise.noiseVectors.itervalues()
    if (_${noiseVector.id})
      xmds_free(_${noiseVector.id});
    @end for
  @end for
  }
};

  @#
@end def

@def integrateAdaptiveGlobals($dict)
  @#
  @set $integrator = dict['caller']
// ********************************************************
// struct used to store step size and noise vector to ensure
// stochastic convergence
struct _dtdWstore_segment${integrator.segmentNumber} {
  real _step;
  @for field in $integrator.integrationFields
    @for noise in $noisesForFieldInIntegrator(field, integrator)
      @set $noiseVector = noise.noiseVectorForField(field)
  real* _${noiseVector.id};
    @end for
  @end for
  @for nv in integrator.dynamicNoiseVectors
  $nv.type* _${nv.id};
  @end for

  _dtdWstore_segment${integrator.segmentNumber}() {
  _step = 0;
  @for field in $integrator.integrationFields
    @for noise in $noisesForFieldInIntegrator(field, integrator)
      @set $noiseVector = noise.noiseVectorForField(field)
  _${noiseVector.id} = NULL;
    @end for
  @end for
  @for nv in integrator.dynamicNoiseVectors
  _${nv.id} = NULL;
  @end for
  }
  ~_dtdWstore_segment${integrator.segmentNumber}() {
  @for field in $integrator.integrationFields
    @for noise in $noisesForFieldInIntegrator(field, integrator)
      @set $noiseVector = noise.noiseVectorForField(field)
  if (_${noiseVector.id})
    xmds_free(_${noiseVector.id});
    @end for
  @end for
  @for nv in integrator.dynamicNoiseVectors
  if (_${nv.id})
    xmds_free(_${nv.id});
  @end for
  }
};
@end def


@def topLevelSequenceBegin($dict)
  @#
  @for noise in $noises
${noise.initialiseSeeds}@slurp

  @end for
  @for noiseVector in $noiseVectors
${noiseVector.initialiseSeeds}@slurp

  @end for
  @#
@end def

@def vectorInitialisationBegin($dict)
  @#
${generateNoisesForVector($dict)}@slurp
  @#
@end def

@def computedVectorEvaluationBegin($dict)
  @#
${generateNoisesForVector($dict)}@slurp
  @#
@end def

@def generateNoisesForVector($dict)
  @#
  @set $caller = dict['caller']
  @set $field = dict['codeBlock'].field
  @set $basis = dict['codeBlock'].basis
  @#
  @set $noisesNeeded = $noises[:]
  @if caller.hasattr('noises')
    @set $noisesNeeded = caller.noises[:]
  @end if
  @if len($noisesNeeded) == 0
    @return
  @end if
  @#
  @set $featureOrdering = ['Driver']
  @set $featureDict = {'field': field, 'basis': basis, 'noises': noisesNeeded, 'extraIndent': 0}
${insertCodeForFeatures('generateNoisesBegin', featureOrdering, featureDict)}@slurp
  @set $extraIndent = featureDict['extraIndent']
  @#
  @capture result
real _var = 1.0 / $field.volumeElementInBasis(basis);

    @for noise in noisesNeeded
      @set $noiseVector = noise.noiseVectorForField(field)
_make_${noise.prefix}_noises(_var, _${noiseVector.id}, ${noiseVector.sizeInBasis(basis)});
    @end for

  @end capture
${result, extraIndent=extraIndent}@slurp
${insertCodeForFeaturesInReverseOrder('generateNoisesEndDeprecated', featureOrdering, featureDict)}@slurp
  @#
@end def

@def integrateFixedStepBegin($dict)
  @#
  @set $integrator = dict['caller']
  @#
  @if not $integratorNeedsNoises(integrator)
    @return
  @end if
  @#
  @for field in integrator.integrationFields
    @set $basis = $deltaAOperatorBasisForFieldInIntegrator(field, integrator)
    @#
const real _${field.name}_var = 1.0/($field.volumeElementInBasis(basis) * _noiseStep);
  @end for
  @#
@end def

@def integrateAdaptiveStepBegin($dict)
  @#
  @set $integrator = dict['caller']
  @#
  @if $integratorNeedsNoises(integrator)
    @for field in integrator.integrationFields
      @set $basis = $deltaAOperatorBasisForFieldInIntegrator(field, integrator)
      @#
  const real _${field.name}_var = 1.0 / $field.volumeElementInBasis(basis);
    @end for
  @end if
  @#
  @if $integratorNeedsNoises(integrator) or not integrator.dynamicNoiseVectors == []
list<_dtdWstore_segment${integrator.segmentNumber}> _noise_list;
list<_dtdWstore_segment${integrator.segmentNumber}>::iterator _active_node;
  @end if
  @#
@end def

@def integrateAdaptiveStepEnd($dict)
  @#
  @set $integrator = dict['caller']
  @#
  @for nv in integrator.dynamicNoiseVectors 
_active_${nv.id} = _${nv.id};
  @end for
  @#
  @if not $integratorNeedsNoises(integrator)
    @return
  @end if
  @#
  @for field in $integrator.integrationFields
    @for noise in $noisesForFieldInIntegrator(field, integrator)
      @set $noiseVector = noise.noiseVectorForField(field)
_active_${noiseVector.id} = _${noiseVector.id};
    @end for
  @end for
@end def

@def integrateFixedStepInnerLoopBegin(dict)
  @#
  @set $integrator = dict['caller']
  @#
  @if not $integratorNeedsNoises(integrator) and not integrator.dynamicNoiseVectors == []
    @return
  @end if
  @#

  @if ('ErrorCheck' in $features) and integrator.dynamicNoiseVectors 
if (_half_step) {
  if (_error_check_loop_iter == 2) { // This is the first loop iteration, so we use the first set of noises.
    @for nv in integrator.dynamicNoiseVectors
      _active_${nv.id} = _${nv.id};
    @end for
  }
  else {// This is the second iteration, so we use the second set of noises
    @for nv in integrator.dynamicNoiseVectors
      _active_${nv.id} = _${nv.id}2;
    @end for
  }
}
else { // For the full step we average the two noises.
    @for nv in integrator.dynamicNoiseVectors
      @#
    ${loopOverVectorsWithInnerContentTemplate([$nv],
    """_${vector.id}[$index] = 0.5*(_${vector.id}[$index] + _${vector.id}2[$index]);
    """, basis = nv.initialBasis), autoIndent=True}@slurp
    _active_${nv.id} = _${nv.id};
    @end for
}
  @end if
  @set $featureOrdering = ['Driver']
  @for field in $integrator.integrationFields
    @set $noises = $noisesForFieldInIntegrator(field, integrator)
    @set $basis = $deltaAOperatorBasisForFieldInIntegrator(field, integrator)
    @set $featureDict = {'field': field, 'basis': basis, 'noises': noises, 'extraIndent': 0}
${insertCodeForFeatures('generateNoisesBegin', featureOrdering, featureDict)}@slurp
    @set $extraIndent = featureDict['extraIndent']
    @#
    @capture result
      @for noise in noises
        @set $noiseVector = noise.noiseVectorForField(field)

_make_${noise.prefix}_noises(_${field.name}_var, _${noiseVector.id}, ${noiseVector.sizeInBasis(basis)});
        @#
        @if 'ErrorCheck' in $features
if (!_half_step) {
  _make_${noise.prefix}_noises(_${field.name}_var, _${noiseVector.id}2, ${noiseVector.sizeInBasis(basis)});
  ${loopOverVectorsWithInnerContentTemplate([$noiseVector],
"""_${vector.id}[$index] = 0.5*(_${vector.id}[$index] + _${vector.id}2[$index]);
""", basis = basis), autoIndent=True}@slurp
}
        @end if
      @end for
    @end capture
${result, extraIndent=extraIndent}@slurp
${insertCodeForFeatures('generateNoisesEndDeprecated', featureOrdering, featureDict)}@slurp
  @end for
  @#
@end def

@def integrateAdaptiveStepInnerLoopBegin(dict)
  @#
  @set $integrator = dict['caller']
  @#
  @if not $integratorNeedsNoises(integrator) and not integrator.dynamicNoiseVectors == []
    @return
  @end if
  @#
if (_noise_list.empty()) { 
  // Noise list empty so start afresh
  _noise_list.push_front(_dtdWstore_segment${integrator.segmentNumber}()); 
  _active_node = _noise_list.begin(); 
  _active_node->_step = _step; 
  @for field in $integrator.integrationFields
    @set $noises = $noisesForFieldInIntegrator(field, integrator)
  
    @for noise in noises
      @set $noiseVector = noise.noiseVectorForField(field)
  _active_${noiseVector.id} = (${noiseVector.type}*) xmds_malloc(sizeof(${noiseVector.type}) * ${noiseVector.allocSize});
  _active_node->_${noiseVector.id} = _active_${noiseVector.id};
    @end for
  
    @set $basis = $deltaAOperatorBasisForFieldInIntegrator(field, integrator)
    @set $featureOrdering = ['Driver']
    @set $featureDict = {'field': field, 'basis': basis, 'noises': noises, 'extraIndent': 0}
  ${insertCodeForFeatures('generateNoisesBegin', featureOrdering, featureDict), autoIndent=True}@slurp
    @set $extraIndent = featureDict['extraIndent']
    @#
    @capture result
      @for noise in noises
        @set $noiseVector = noise.noiseVectorForField(field)
_make_${noise.prefix}_noises(_${field.name}_var/_step, _active_${noiseVector.id}, ${noiseVector.sizeInBasis(basis)});
      @end for
    @end capture
  ${result, autoIndent=True, extraIndent=extraIndent}@slurp
  ${insertCodeForFeatures('generateNoisesEndDeprecated', featureOrdering, featureDict), autoIndent=True}@slurp
  @end for
  @for nv in integrator.dynamicNoiseVectors

  _active_${nv.id} =  (${nv.type}*) xmds_malloc(sizeof(${nv.type}) * ${nv.allocSize});
  _active_node->_${nv.id} = _active_${nv.id};
  _${nv.id}_evaluate(_step);
  @end for
} else if (_step*(1.0 + _EPSILON) < _noise_list.begin()->_step) {
  // Create new smallest time step
  
  // If the step is greater than 50% of the current smallest step size
  // then we should just use half the step size because we are going to have
  // to do the other half at some point too.
  
  const real _old_smallest_step = _noise_list.begin()->_step;
  
  if (_step > 0.5*_old_smallest_step*(1.0 + _EPSILON))
    _step = 0.5*_old_smallest_step;
  
  @for field in integrator.integrationFields
    @set $noises = $noisesForFieldInIntegrator(field, integrator)
    @for noise in noises
      @set $noiseVector = noise.noiseVectorForField(field)
  _active_${noiseVector.id} = (${noiseVector.type}*) xmds_malloc(sizeof(${noiseVector.type}) * ${noiseVector.allocSize});
    @end for
  
    @set $basis = $deltaAOperatorBasisForFieldInIntegrator(field, integrator)
    @set $featureOrdering = ['Driver']
    @set $featureDict = {'field': field, 'basis': basis, 'noises': noises, 'extraIndent': 0}
  ${insertCodeForFeatures('generateNoisesBegin', featureOrdering, featureDict), autoIndent=True}@slurp
    @set $extraIndent = featureDict['extraIndent']
    @#
    @capture result
      @for noise in noises
        @if noise.noiseDistribution == 'gaussian'
${breakGaussianNoiseInFieldInBasis(noise, field, basis)}@slurp
        @elif noise.noiseDistribution == 'poissonian'
${breakPoissonianNoiseInFieldInBasis(noise, field, basis)}@slurp
        @end if
      @end for
    @end capture
  ${result, autoIndent=True, extraIndent=extraIndent}@slurp
  ${insertCodeForFeaturesInReverseOrder('generateNoisesEndDeprecated', featureOrdering, featureDict), autoIndent=True}@slurp
  @end for
  @#

  @for nv in integrator.dynamicNoiseVectors
  _active_${nv.id} = (${nv.type}*) xmds_malloc(sizeof(${nv.type}) * ${nv.allocSize});

    @set $featureOrdering = ['Driver']
    @set $featureDict = {'field': field, 'basis': nv.initialBasis, 'extraIndent': 0}
  ${insertCodeForFeatures('generateNoisesBegin', featureOrdering, featureDict), autoIndent=True}@slurp
    @set $extraIndent = featureDict['extraIndent']
    @#
    @capture result
        @if nv.randomVariable.noiseDistribution == 'gaussian'
${breakGaussianNoiseVectorInFieldInBasis(nv, basis)}@slurp
        @elif nv.randomVariable.noiseDistribution == 'poissonian'
${breakPoissonianNoiseVectorInFieldInBasis(nv, field, basis)}@slurp
        @end if
    @end capture
  ${result, autoIndent=True, extraIndent=extraIndent}@slurp
  ${insertCodeForFeaturesInReverseOrder('generateNoisesEnd', featureOrdering, featureDict), autoIndent=True}@slurp
  @end for
  @#
  
  _noise_list.push_front(_dtdWstore_segment${integrator.segmentNumber}());
  _active_node = _noise_list.begin();
  _active_node->_step = _step;
  @for field in integrator.integrationFields
    @for noise in $noisesForFieldInIntegrator(field, integrator)
      @set $noiseVector = noise.noiseVectorForField(field)
  _active_node->_${noiseVector.id} = _active_${noiseVector.id};
    @end for
  @end for
  @for nv in integrator.dynamicNoiseVectors
  _active_node->_${nv.id} = _active_${nv.id};
  @end for
} else {
  // Use step already attempted
  for (_active_node = _noise_list.begin(); (_active_node != _noise_list.end()) && (_active_node->_step <= _step*(1.0 + _EPSILON)); _active_node++)
    ;
  
  _active_node--;
  _step = _active_node->_step;
  @for field in integrator.integrationFields
    @for noise in $noisesForFieldInIntegrator(field, integrator)
      @set $noiseVector = noise.noiseVectorForField(field)
  _active_${noiseVector.id} = _active_node->_${noiseVector.id};
    @end for
  @end for
  @for nv in integrator.dynamicNoiseVectors
  _active_${nv.id} = _active_node->_${nv.id};
  @end for
  
  if (_break_next && abs(${propagationDimension} - _${propagationDimension}_ini + _step - _${propagationDimension}_break_next) > _step*_EPSILON)
    _break_next = false;
} 

  @#
@end def

@def breakGaussianNoiseInFieldInBasis($noise, $field, $basis)
@*doc:
Return the code to generate a new smaller gaussian noise from a previous noise.

The previous noise had a time step of ``old_smallest_step`` a variable available in the C
code, not in the template itself.
*@
  @#
  @set $noiseVector = noise.noiseVectorForField(field)
  @#
  @# First allocate the new noise vector
// Split a gaussian noise

  @# Then generate a new noise of the appropriate variance
_make_${noise.prefix}_noises(_${field.name}_var * (_old_smallest_step - _step)/(_step * _old_smallest_step), 
    _active_${noiseVector.id}, ${noiseVector.sizeInBasis(basis)});

  @# Then add the old noise.
  @# When adding the old noise, the first step is to get a pointer to the old noise itself.
  @# This pointer is called _old_${noiseVector.id}
// Now complete creation of the new noise.
${noiseVector.type}* const _old_${noiseVector.id} = _noise_list.begin()->_${noiseVector.id};

  @# Now do the actual adding. This code creates a loop over the noiseVector
  @# adding the old vector at each point.
${loopOverVectorsWithInnerContentTemplate([$noiseVector], 
"""_active_${vector.id}[$index] += _old_${vector.id}[$index];
""", basis = basis), autoIndent=True}@slurp

  @#
@end def

@def breakPoissonianNoiseInFieldInBasis($noise, $field, $basis)
@*doc:
Return the code to generate a new smaller poissonian noise from a previous noise.

The previous noise had a time step of ``_old_smallest_step`` a variable available in the C
code, not in the template itself.
*@
  @#
  @set $noiseVector = noise.noiseVectorForField(field)
  @#
// Split a poissonian noise

${noiseVector.type}* const _old_${noiseVector.id} = _noise_list.begin()->_${noiseVector.id};

_split_${noise.prefix}_noises(_${field.name}_var / _step, _${field.name}_var / _old_smallest_step, _active_${noiseVector.id}, _old_${noiseVector.id}, ${noiseVector.sizeInBasis(basis)});

  @#
@end def

@def breakGaussianNoiseVectorInFieldInBasis($noiseVector, $basis)
@*doc:
Return the code to generate a new smaller gaussian noise from a previous noise.

The previous noise had a time step of ``old_smallest_step`` a variable available in the C
code, not in the template itself.
*@
  @#
// Split a gaussian noise
  @# Then generate a new noise of the appropriate variance
_${noiseVector.id}_evaluate((_step * _old_smallest_step)/(_old_smallest_step - _step));

  @# Then add the old noise.
  @# When adding the old noise, the first step is to get a pointer to the old noise itself.
  @# This pointer is called _old_${noiseVector.id}
// Now complete creation of the new noise.
${noiseVector.type}* const _old_${noiseVector.id} = _noise_list.begin()->_${noiseVector.id};

  @# Now do the actual adding. This code creates a loop over the noiseVector
  @# adding the old vector at each point.
${loopOverVectorsWithInnerContentTemplate([$noiseVector], 
"""_active_${vector.id}[$index] += _old_${vector.id}[$index];
""", basis = basis), autoIndent=True}@slurp

  @#
@end def

@def breakPoissonianNoiseVectorInFieldInBasis($noiseVector, $field, $basis)
@*doc:
Return the code to generate a new smaller poissonian noise from a previous noise.

The previous noise had a time step of ``_old_smallest_step`` a variable available in the C
code, not in the template itself.
*@
  @#
// Split a poissonian noise
${noiseVector.type}* const _old_${noiseVector.id} = _noise_list.begin()->_${noiseVector.id};

_split_${noiseVector.id}_noises(_${field.name}_var / _step, _${field.name}_var / _old_smallest_step, _active_${noiseVector.id}, _old_${noiseVector.id}, ${noiseVector.sizeInBasis(basis)});

  @#
@end def

@def adaptiveStepSucceeded(dict)
  @#
  @set $integrator = dict['caller']
  @#
  @if not $integratorNeedsNoises(integrator) and not integrator.dynamicNoiseVectors == []
    @return
  @end if
  @#

// Trim dtdW tree
_active_node++;
if (_active_node == _noise_list.end())
  _noise_list.clear();
else {
  for (list<_dtdWstore_segment${integrator.segmentNumber}>::iterator _temp_iter = _active_node; _temp_iter != _noise_list.end(); _temp_iter++) {
    _temp_iter->_step -= _step;
    real _temp_step = _temp_iter->_step;
    
  @for field in integrator.integrationFields
    @for noise in $noisesForFieldInIntegrator(field, integrator)
      @set $noiseVector = noise.noiseVectorForField(field)
    ${noiseVector.type}* _temp_${noiseVector.id} = _temp_iter->_${noiseVector.id};
    ${loopOverVectorsWithInnerContentTemplate([$noiseVector],
"""_temp_${vector.id}[$index] = (_temp_${vector.id}[$index]*(_temp_step + _step) - _active_${vector.id}[$index]*_step)/_temp_step;
"""), autoIndent=True}@slurp
    @end for
  @end for

  @for nv in integrator.dynamicNoiseVectors
    ${nv.type}* _temp_${nv.id} = _temp_iter->_${nv.id};
    ${loopOverVectorsWithInnerContentTemplate([$nv],
"""_temp_${vector.id}[$index] = (_temp_${vector.id}[$index]*(_temp_step + _step) - _active_${vector.id}[$index]*_step)/_temp_step;
"""), autoIndent=True}@slurp
  @end for
  }
  
  _noise_list.erase(_noise_list.begin(), _active_node);
}
  @#
@end def

