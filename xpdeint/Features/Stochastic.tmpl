@*
Stochastic.tmpl

Created by Graham Dennis on 2007-12-11.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Features._Stochastic

@from xpdeint.Operators.DeltaAOperator import DeltaAOperator

@def description: Stochastic
@attr featureName = 'Stochastic'

@*
  Globals
*@
@def globals
  @#
  @super
  @#
  @set $noisesNeeded = filter(lambda x: x.noiseDistribution in ('gaussian', 'poissonian'), $noises)
// ********************************************************
// struct used to store step size and noise vector to ensure
// stochastic convergence
struct _dtdWstore {
  double _step;
  @for noise in noisesNeeded
    @for noiseVector in noise.noiseVectors.itervalues()
  double* _${noiseVector.id};
    @end for
  @end for
  _dtdWstore() {
    _step = 0;
  @for noise in noisesNeeded
    @for noiseVector in noise.noiseVectors.itervalues()
    _${noiseVector.id} = NULL;
    @end for
  @end for
  }
  ~_dtdWstore() {
  @for noise in noisesNeeded
    @for noiseVector in noise.noiseVectors.itervalues()
    if (_${noiseVector.id})
      xmds_free(_${noiseVector.id});
    @end for
  @end for
  }
};

  @for noiseAlias in $noiseAliases
${noiseAlias.type}* _${noiseAlias.id}2;
  @end for
  @#
@end def

@def topLevelSequenceBegin($dict)
  @#
  @for noise in $noises
${noise.initialiseSeeds}@slurp

  @end for
  @#
@end def

@def vectorInitialisationBegin($dict)
  @#
${generateNoisesForVector($dict)}@slurp
  @#
@end def

@def computedVectorEvaluationBegin($dict)
  @#
${generateNoisesForVector($dict)}@slurp
  @#
@end def

@def generateNoisesForVector($dict)
  @#
  @set $caller = dict['caller']
  @set $field = dict['field']
  @set $space = dict['space']
  @#
  @set $noisesNeeded = $noises[:]
  @if caller.hasattr('noises')
    @set $noisesNeeded = caller.noises[:]
  @end if
  @if len($noisesNeeded) == 0
    @return
  @end if
  @#
  @set $featureOrdering = ['Driver']
  @set $featureDict = {'field': field, 'space': space, 'noises': noisesNeeded, 'extraIndent': 0}
${insertCodeForFeatures('generateNoisesBegin', featureOrdering, featureDict)}@slurp
  @set $extraIndent = featureDict['extraIndent']
  @#
  @capture result
double _var = 1.0 / $field.volumeElementInSpace($space);

    @for noise in noisesNeeded
      @set $noiseVector = noise.noiseVectorForField(field)
_make_${noise.prefix}_noises(_var, _${noiseVector.id}, ${sizeOfVectorInSpace(noiseVector, space)});
    @end for

  @end capture
${result, extraIndent=extraIndent}@slurp
${insertCodeForFeaturesInReverseOrder('generateNoisesEnd', featureOrdering, featureDict)}@slurp
  @#
@end def

@def integrateFixedStepBegin($dict)
  @#
  @set $integrator = dict['caller']
  @#
  @if not $integratorNeedsNoises(integrator)
    @return
  @end if
  @#
  @for field in integrator.integrationFields
    @set $space = $deltaAOperatorSpaceForFieldInIntegrator(field, integrator)
    @#
const double _${field.name}_var = 1.0/($field.volumeElementInSpace($space) * _noiseStep);
  @end for
  @#
@end def

@def integrateAdaptiveStepBegin($dict)
  @#
  @set $integrator = dict['caller']
  @#
  @if not $integratorNeedsNoises(integrator)
    @return
  @end if
  @#
  @for field in integrator.integrationFields
    @set $space = $deltaAOperatorSpaceForFieldInIntegrator(field, integrator)
    @#
const double _${field.name}_var = 1.0 / $field.volumeElementInSpace($space);
  @end for

list<_dtdWstore> _noise_list;
list<_dtdWstore>::iterator _active_node;
  @#
@end def

@def integrateAdaptiveStepEnd($dict)
  @#
  @set $integrator = dict['caller']
  @#
  @if not $integratorNeedsNoises(integrator)
    @return
  @end if
  @#
  @for field in $integrator.integrationFields
    @for noise in $noisesForFieldInIntegrator(field, integrator)
      @set $noiseVector = noise.noiseVectorForField(field)
_active_${noiseVector.id} = _${noiseVector.id};
    @end for
  @end for
@end def

@def integrateFixedStepInnerLoopBegin(dict)
  @#
  @set $integrator = dict['caller']
  @#
  @if not $integratorNeedsNoises(integrator)
    @return
  @end if
  @#
  @set $featureOrdering = ['Driver']
  @for field in $integrator.integrationFields
    @set $noises = $noisesForFieldInIntegrator(field, integrator)
    @set $space = $deltaAOperatorSpaceForFieldInIntegrator(field, integrator)
    @set $featureDict = {'field': field, 'space': space, 'noises': noises, 'extraIndent': 0}
${insertCodeForFeatures('generateNoisesBegin', featureOrdering, featureDict)}@slurp
    @set $extraIndent = featureDict['extraIndent']
    @#
    @capture result
      @for noise in noises
        @set $noiseVector = noise.noiseVectorForField(field)

_make_${noise.prefix}_noises(_${field.name}_var, _${noiseVector.id}, ${sizeOfVectorInSpace(noiseVector, integrator.homeSpace)});
        @#
        @if 'ErrorCheck' in $features
if (!_half_step) {
  _make_${noise.prefix}_noises(_${field.name}_var, _${noiseVector.id}2, ${sizeOfVectorInSpace(noiseVector, integrator.homeSpace)});
  ${loopOverVectorsWithInnerContentTemplate([$noiseVector],
"""_${vector.id}[$index] = 0.5*(_${vector.id}[$index] + _${vector.id}2[$index]);
"""), autoIndent=True}@slurp
}
        @end if
      @end for
    @end capture
${result, extraIndent=extraIndent}@slurp
${insertCodeForFeatures('generateNoisesEnd', featureOrdering, featureDict)}@slurp
  @end for
  @#
@end def

@def integrateAdaptiveStepInnerLoopBegin(dict)
  @#
  @set $integrator = dict['caller']
  @set $space = integrator.homeSpace
  @#
  @if not $integratorNeedsNoises(integrator)
    @return
  @end if
  @#
if (_noise_list.empty()) { 
  // Noise list empty so start afresh
  _noise_list.push_front(_dtdWstore()); 
  _active_node = _noise_list.begin(); 
  _active_node->_step = _step; 
  @for field in $integrator.integrationFields
    @set $noises = $noisesForFieldInIntegrator(field, integrator)
  
    @for noise in noises
      @set $noiseVector = noise.noiseVectorForField(field)
  _active_${noiseVector.id} = (${noiseVector.type}*) xmds_malloc(sizeof(${noiseVector.type}) * ${allocSizeOfVector(noiseVector)});
  _active_node->_${noiseVector.id} = _active_${noiseVector.id};
    @end for
  
    @set $space = $deltaAOperatorSpaceForFieldInIntegrator(field, integrator)
    @set $featureOrdering = ['Driver']
    @set $featureDict = {'field': field, 'space': space, 'noises': noises, 'extraIndent': 0}
  ${insertCodeForFeatures('generateNoisesBegin', featureOrdering, featureDict), autoIndent=True}@slurp
    @set $extraIndent = featureDict['extraIndent']
    @#
    @capture result
      @for noise in noises
        @set $noiseVector = noise.noiseVectorForField(field)
_make_${noise.prefix}_noises(_${field.name}_var/_step, _active_${noiseVector.id}, ${sizeOfVectorInSpace(noiseVector, space)});
      @end for
    @end capture
  ${result, autoIndent=True, extraIndent=extraIndent}@slurp
  ${insertCodeForFeatures('generateNoisesEnd', featureOrdering, featureDict), autoIndent=True}@slurp
  @end for
} else if (_step*(1.0 + _EPSILON) < _noise_list.begin()->_step) {
  // Create new smallest time step
  
  // If the step is greater than 50% of the current smallest step size
  // then we should just use half the step size because we are going to have
  // to do the other half at some point too.
  
  const double _old_smallest_step = _noise_list.begin()->_step;
  
  if (_step > 0.5*_old_smallest_step*(1.0 + _EPSILON))
    _step = 0.5*_old_smallest_step;
  
  @for field in integrator.integrationFields
    @set $noises = $noisesForFieldInIntegrator(field, integrator)
    @for noise in noises
      @set $noiseVector = noise.noiseVectorForField(field)
  _active_${noiseVector.id} = (${noiseVector.type}*) xmds_malloc(sizeof(${noiseVector.type}) * ${allocSizeOfVector(noiseVector)});
    @end for
  
    @set $space = $deltaAOperatorSpaceForFieldInIntegrator(field, integrator)
    @set $featureOrdering = ['Driver']
    @set $featureDict = {'field': field, 'space': space, 'noises': noises, 'extraIndent': 0}
  ${insertCodeForFeatures('generateNoisesBegin', featureOrdering, featureDict), autoIndent=True}@slurp
    @set $extraIndent = featureDict['extraIndent']
    @#
    @capture result
      @for noise in noises
        @if noise.noiseDistribution == 'gaussian'
${breakGaussianNoiseInFieldInSpace(noise, field, space)}@slurp
        @elif noise.noiseDistribution == 'poissonian'
${breakPoissonianNoiseInFieldInSpace(noise, field, space)}@slurp
        @end if
      @end for
    @end capture
  ${result, autoIndent=True, extraIndent=extraIndent}@slurp
  ${insertCodeForFeaturesInReverseOrder('generateNoisesEnd', featureOrdering, featureDict), autoIndent=True}@slurp
  @end for
  @#
  
  _noise_list.push_front(_dtdWstore());
  _active_node = _noise_list.begin();
  _active_node->_step = _step;
  @for field in integrator.integrationFields
    @for noise in $noisesForFieldInIntegrator(field, integrator)
      @set $noiseVector = noise.noiseVectorForField(field)
  _active_node->_${noiseVector.id} = _active_${noiseVector.id};
    @end for
  @end for
} else {
  // Use step already attempted
  for (_active_node = _noise_list.begin(); (_active_node != _noise_list.end()) && (_active_node->_step <= _step*(1.0 + _EPSILON)); _active_node++)
    ;
  
  _active_node--;
  _step = _active_node->_step;
  @for field in integrator.integrationFields
    @for noise in $noisesForFieldInIntegrator(field, integrator)
      @set $noiseVector = noise.noiseVectorForField(field)
  _active_${noiseVector.id} = _active_node->_${noiseVector.id};
    @end for
  @end for
  
  if (_break_next && fabs(${propagationDimension} - _${propagationDimension}_ini + _step - _${propagationDimension}_break_next) > _step*_EPSILON)
    _break_next = false;
} 

  @#
@end def

@def breakGaussianNoiseInFieldInSpace($noise, $field, $space)
@*doc:
Return the code to generate a new smaller gaussian noise from a previous noise.

The previous noise had a time step of ``old_smallest_step`` a variable available in the C
code, not in the template itself.
*@
  @#
  @set $noiseVector = noise.noiseVectorForField(field)
  @#
  @# First allocate the new noise vector
// Split a gaussian noise

  @# Then generate a new noise of the appropriate variance
_make_${noise.prefix}_noises(_${field.name}_var * (_old_smallest_step - _step)/(_step * _old_smallest_step), 
    _active_${noiseVector.id}, ${sizeOfVectorInSpace(noiseVector, space)});

  @# Then add the old noise.
  @# When adding the old noise, the first step is to get a pointer to the old noise itself.
  @# This pointer is called _old_${noiseVector.id}
// Now complete creation of the new noise.
${noiseVector.type}* const _old_${noiseVector.id} = _noise_list.begin()->_${noiseVector.id};

  @# Now do the actual adding. This code creates a loop over the noiseVector
  @# adding the old vector at each point.
${loopOverVectorsWithInnerContentTemplate([$noiseVector], 
"""_active_${vector.id}[$index] += _old_${vector.id}[$index];
"""), autoIndent=True}@slurp

  @#
@end def

@def breakPoissonianNoiseInFieldInSpace($noise, $field, $space)
@*doc:
Return the code to generate a new smaller poissonian noise from a previous noise.

The previous noise had a time step of ``_old_smallest_step`` a variable available in the C
code, not in the template itself.
*@
  @#
  @set $noiseVector = noise.noiseVectorForField(field)
  @#
// Split a poissonian noise

${noiseVector.type}* const _old_${noiseVector.id} = _noise_list.begin()->_${noiseVector.id};

_split_${noise.prefix}_noises(_${field.name}_var / _step, _${field.name}_var / _old_smallest_step, _active_${noiseVector.id}, _old_${noiseVector.id}, ${sizeOfVectorInSpace(noiseVector, space)});

  @#
@end def

@def adaptiveStepSucceeded(dict)
  @#
  @set $integrator = dict['caller']
  @#
  @if not $integratorNeedsNoises(integrator)
    @return
  @end if
  @#

// Trim dtdW tree
_active_node++;
if (_active_node == _noise_list.end())
  _noise_list.clear();
else {
  for (list<_dtdWstore>::iterator _temp_iter = _active_node; _temp_iter != _noise_list.end(); _temp_iter++) {
    _temp_iter->_step -= _step;
    double _temp_step = _temp_iter->_step;
    
  @for field in integrator.integrationFields
    @for noise in $noisesForFieldInIntegrator(field, integrator)
      @set $noiseVector = noise.noiseVectorForField(field)
    ${noiseVector.type}* _temp_${noiseVector.id} = _temp_iter->_${noiseVector.id};
    ${loopOverVectorsWithInnerContentTemplate([$noiseVector],
"""_temp_${vector.id}[$index] = (_temp_${vector.id}[$index]*(_temp_step + _step) - _active_${vector.id}[$index]*_step)/_temp_step;
"""), autoIndent=True}@slurp
    @end for
  @end for
  }
  
  _noise_list.erase(_noise_list.begin(), _active_node);
}
  @#
@end def

