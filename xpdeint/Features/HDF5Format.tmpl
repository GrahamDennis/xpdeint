@*
HDF5Format.tmpl

Created by Graham Dennis on 2009-01-24.
Copyright (c) 2009 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Features.OutputFormat
@from xpdeint.Geometry.NonUniformDimensionRepresentation import NonUniformDimensionRepresentation
@from xpdeint.Geometry.SplitUniformDimensionRepresentation import SplitUniformDimensionRepresentation
@from xpdeint.CallOnceGuards import callOnceGuard

@def description: HDF5 output format

@attr $outputArguments = [('hid_t', 'hdf5_file'), ('const char*', '_dataFilename')]

@def cflags
-lhdf5 -lhdf5_hl@slurp
@end def

@attr $name = 'hdf5'
@attr $mpiSafe = True

@@callOnceGuard
@def includes
#include <hdf5.h>
#include <hdf5_hl.h>
@end def

@def writeOutSetup($args, $filename)
  @super(args, filename)
  @# Due to funkyness, the parameter name here must be the same as the variable name
  @silent args.update({'hdf5_file': 'hdf5_file', '_dataFilename': '_dataFilename'})
hid_t hdf5_file;

char _dataFilename[200];
strncpy(_dataFilename, ${filename}, 200);
strcat(_dataFilename, ".h5");

/* Create a HDF5 file */
if (_outfile)
  hdf5_file = H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
@end def

@def writeOutTearDown
if (_outfile)
  H5Fclose(hdf5_file);
  @super
@end def

@def writeOutFunctionImplementationBody($dict)
  @#
${writeOutFunctionImplementationBegin(dict)}@slurp

  @set $featureOrdering = ['Driver']
  @set $featureDict = dict.copy()
  @set $featureDict['extraIndent'] = 0
${insertCodeForFeatures('binaryWriteOutBegin', featureOrdering, featureDict)}@slurp
  @set $extraIndent = featureDict['extraIndent']

${writeOutFunctionContents(dict), extraIndent=extraIndent}@slurp

${insertCodeForFeaturesInReverseOrder('binaryWriteOutEnd', featureOrdering, featureDict)}@slurp

${writeOutFunctionImplementationEnd(dict)}@slurp
  @#
@end def

@def writeOutFunctionContents($dict)
  @#
  @set $fp = dict['fp']
  @set $baseFilename = dict['baseFilename']
  @set $groupID = dict['groupID']
  @set $field = dict['field']
  @set $space = dict['space']
  @set $dependentVariables = dict['dependentVariables']
  @set $componentCount = 0
  @for $variable in $dependentVariables
    @set $componentCount += len($variable.vector.components)
    @if $variable.vector.type == 'complex'
      @set $componentCount += len($variable.vector.components)
    @end if
  @end for
  @set dict['componentCount'] = componentCount
  @#

/* Create the group for this data */
hid_t group = H5Gcreate(hdf5_file, "/${groupID}", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);

fprintf($fp, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/${groupID}\"/>\n");
fprintf($fp, "%s\n", _dataFilename);
fprintf($fp, "    </Stream>\n");

/* Create the coordinate data sets */
hsize_t coordinate_length;
hid_t coordinate_dataspace;
  @for dim in field.dimensions
    @set $dimRep = dim.inSpace(space)
coordinate_length = ${dimRep.globalLattice};
coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
    @set $dataType = {'double': 'H5T_NATIVE_DOUBLE', 'long': 'H5T_NATIVE_LONG'}[$dimRep.type]
hid_t dataset_${dimRep.name} = H5Dcreate(hdf5_file, "/${groupID}/${dimRep.name}", ${dataType}, coordinate_dataspace, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
    @if not isinstance(dimRep, NonUniformDimensionRepresentation)
      @set $dimArrayName = c'${dimRep.name}_data'
${dimRep.type} ${dimArrayName}[${dimRep.globalLattice}];
for (long _i0 = 0; _i0 < ${dimRep.globalLattice}; _i0++) {
  ${dimArrayName}[_i0] = ${dimRep.minimum} + ${dimRep.stepSize} * _i0;
}
    @else
      @set $dimArrayName = dimRep.arrayName
    @end if
H5Dwrite(dataset_${dimRep.name}, $dataType, H5S_ALL, H5S_ALL, H5P_DEFAULT, ${dimArrayName});
H5DSset_scale(dataset_${dimRep.name}, "${dimRep.name}");

H5Sclose(coordinate_dataspace);
  @end for

hsize_t file_dims[] = {${', '.join(dim.inSpace(space).globalLattice for dim in field.dimensions)}};
hid_t file_dataspace;
file_dataspace = H5Screate_simple(${len(field.dimensions)}, file_dims, NULL);
  @for variable in dependentVariables
    @if $variable.vector.type == 'double'
      @set $variable['separatedComponents'] = list(enumerate($variable.components))
    @else
      @set $components = []
      @set variable['separatedComponents'] = components
      @for offset, componentName in enumerate($variable.components)
        @silent components.extend([(2*offset, componentName + 'R'), (2*offset+1, componentName + 'I')])
      @end for
    @end if
    @for offset, componentName in $variable.separatedComponents
hid_t dataset_${componentName} = H5Dcreate(hdf5_file, "/${groupID}/${componentName}", H5T_NATIVE_DOUBLE, file_dataspace, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
      @for dimNum, dim in enumerate(field.dimensions)
H5DSattach_scale(dataset_${componentName}, dataset_${dim.inSpace(space).name}, ${dimNum});
      @end for
    @end for
  @end for
  @for dim in field.dimensions
    @set $dimRep = dim.inSpace(space)
H5Dclose(dataset_${dimRep.name});
  @end for

  @# This is where all of the magic MPI code goes
  @set $featureOrdering = ['Driver']
  @set $featureDict = dict.copy()
  @set $featureDict['extraIndent'] = 0
${insertCodeForFeatures('binaryWriteOutWriteDataBegin', $featureOrdering, featureDict)}@slurp
  @set $extraIndent = featureDict['extraIndent']

${writeData(dict), extraIndent=extraIndent}@slurp

  @# This is where the rest of the magic MPI code goes
${insertCodeForFeaturesInReverseOrder('binaryWriteOutWriteDataEnd', $featureOrdering, featureDict)}@slurp

  @for variable in dependentVariables
    @for offset, componentName in $variable.separatedComponents
H5Dclose(dataset_${componentName});
    @end for
  @end for

H5Sclose(file_dataspace);
H5Gclose(group);

  @#
@end def

@def writeData(dict)
  @set $field = dict['field']
  @set $space = dict['space']
  @set $dependentVariables = dict['dependentVariables']
  @set $componentCount = 0
  @for $variable in $dependentVariables
    @set $componentCount += len($variable.vector.components)
    @if $variable.vector.type == 'complex'
      @set $componentCount += len($variable.vector.components)
    @end if
  @end for
  @set dict['componentCount'] = componentCount
/* Create the data space */
  @set $dimensionCount = len(field.dimensions)
  @set $fileDimReps = [dim.inSpace(space) for dim in field.dimensions]
  @set $memDimReps = [dim.inSpace(space) for dim in field.orderedDimensionsInSpace(space)]
hsize_t file_start[${dimensionCount}] = {${', '.join(dimRep.localOffset for dimRep in fileDimReps)}};
hsize_t mem_dims[${dimensionCount+1}] = {${', '.join(dimRep.localLattice for dimRep in memDimReps)}, 1};
hsize_t mem_start[${dimensionCount+1}] = {${', '.join(['0']*(dimensionCount+1))}};
hsize_t mem_stride[${dimensionCount+1}] = {${', '.join(['1']*dimensionCount + ['0'])}};
hsize_t mem_count[${dimensionCount+1}] = {${', '.join(dimRep.localLattice for dimRep in memDimReps)}, 1};

hid_t mem_dataspace;
  @for variable in dependentVariables
    @set $components = $variable.separatedComponents
mem_dims[${dimensionCount}] = ${len(components)};
mem_dataspace = H5Screate_simple(${dimensionCount+1}, mem_dims, NULL);
mem_stride[${dimensionCount}] = ${len(components)};

    @capture writeLoopContents
      @for offset, componentName in components
mem_start[${dimensionCount}] = $offset;
H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
        @# 
        @#  This looks like a typo because 'mem_stride' and 'mem_count' are used with 'file_start' are used here.
        @#  But it isn't a typo. The idea here is that the selection we want to make in the file has the same
        @#  number of elements in each dimension and the same stride as in memory (but ignoring the last dimension).
        @#  The only difference is the starting position for the selection.
        @#
H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);

H5Dwrite(dataset_${componentName}, H5T_NATIVE_DOUBLE, mem_dataspace, file_dataspace, H5P_DEFAULT, ${variable.arrayName});
      @end for
    @end capture
    @#
    @# Construct a list of (fileDimNum, memDimNum, dimRep) tuples. This is necessary
    @# for the case where we are using a distributed MPI driver with FFT's
    @# and the first two dimensions are transformed. In this situation, the
    @# first and second dimensions are transposed.
    @#
    @set dimRepOrdering = [(fileDimNum, memDimReps.index(dimRep), dimRep) \
                           for fileDimNum, dimRep in enumerate(fileDimReps)]
    @# Permit the driver to modify the writeLoopContents
    @set $featureOrdering = ['Driver']
    @set $dict = {'writeLoopContents': writeLoopContents,
                  'dimRepOrdering': dimRepOrdering}
    @silent $insertCodeForFeatures('writeDataHDF5ModifyLoopContents', featureOrdering, dict)
    @set $writeLoopContents = dict['writeLoopContents']
    @#
    @# The object passed as the first argument to this next call is a 
// Select hyperslabs of memory and file data spaces and then write
${splitUniformDataSelect(dimRepOrdering, writeLoopContents)}@slurp

H5Sclose(mem_dataspace);
  @end for
@end def

@def splitUniformDataSelect(remainingDimReps, writeLoopContents)
  @if not remainingDimReps
${writeLoopContents}@slurp
  @else
    @set fileDimNum, memDimNum, dimRep = remainingDimReps.pop(0)
    @if isinstance(dimRep, SplitUniformDimensionRepresentation)
for (bool _positive_${dimRep.name} = true; ; _positive_${dimRep.name} = false) {
  if (_positive_${dimRep.name}) {
    mem_start[$memDimNum] = 0;
    if ($dimRep.localOffset >= (($dimRep.globalLattice-1)/2 +1)) // No positive values are stored in this rank.
      continue;
    mem_count[$memDimNum] = MIN((($dimRep.globalLattice-1)/2 +1) - $dimRep.localOffset, $dimRep.localLattice);
    file_start[$fileDimNum] = $dimRep.globalLattice/2 + $dimRep.localOffset;
  } else {
    if (($dimRep.globalLattice-1)/2+1 < $dimRep.localOffset) // Only negative values are stored in this rank.
      mem_start[$memDimNum] = 0;
    else
      mem_start[$memDimNum] = ($dimRep.globalLattice-1)/2+1 - $dimRep.localOffset;
    file_start[$fileDimNum] = mem_start[$memDimNum] + $dimRep.localOffset - (($dimRep.globalLattice-1)/2+1);
    if ($dimRep.localLattice <= mem_start[$memDimNum]) // No negative values are stored in this rank.
      break; // end loop over this dimension
    mem_count[$memDimNum] = $dimRep.localLattice - mem_start[$memDimNum]; // To the end of this dimension
  }
  
  ${splitUniformDataSelect(remainingDimReps, writeLoopContents), autoIndent=True}@slurp
  
  if (!_positive_${dimRep.name})
    break;
}
    @else
${splitUniformDataSelect(remainingDimReps, writeLoopContents)}@slurp
    @end if
  @end if
@end def
