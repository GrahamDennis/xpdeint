@*
HDF5Format.tmpl

Created by Graham Dennis on 2009-01-24.
Copyright (c) 2009 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Features._HDF5Format
@from xpdeint.Geometry.NonUniformDimensionRepresentation import NonUniformDimensionRepresentation
@from xpdeint.CallOnceGuards import callOnceGuard

@def description: HDF5 output format

@attr $outputArguments = [('hid_t', 'hdf5_file'), ('const char*', '_dataFilename')]

@def cflags
  @#
  @super
  @#
 -lhdf5_hl@slurp
  @#
@end def

@attr $name = 'hdf5'
@attr $mpiSafe = True

@@callOnceGuard
@def includes
  @#
  @super
  @#
#include <hdf5_hl.h>
@end def

@def writeOutSetup($args, $filename)
  @super(args, filename)
  @# Due to funkyness, the parameter name here must be the same as the variable name
  @silent args.update({'hdf5_file': 'hdf5_file', '_dataFilename': '_dataFilename'})
hid_t hdf5_file;

char _dataFilename[200];
strncpy(_dataFilename, ${filename}, 200);
strcat(_dataFilename, ".h5");

/* Create a HDF5 file */
if (_outfile)
  hdf5_file = H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
@end def

@def writeOutTearDown
if (_outfile)
  H5Fclose(hdf5_file);
  @super
@end def

@def writeOutFunctionImplementationBody($dict)
  @#
${writeOutFunctionImplementationBegin(dict)}@slurp

  @set $featureOrdering = ['Driver']
  @set $featureDict = dict.copy()
  @set $featureDict['extraIndent'] = 0
${insertCodeForFeatures('binaryWriteOutBegin', featureOrdering, featureDict)}@slurp
  @set $extraIndent = featureDict['extraIndent']

${writeOutFunctionContents(dict), extraIndent=extraIndent}@slurp

${insertCodeForFeaturesInReverseOrder('binaryWriteOutEnd', featureOrdering, featureDict)}@slurp

${writeOutFunctionImplementationEnd(dict)}@slurp
  @#
@end def

@def writeOutFunctionContents($dict)
  @#
  @set $fp = dict['fp']
  @set $baseFilename = dict['baseFilename']
  @set $groupID = dict['groupID']
  @set $field = dict['field']
  @set $space = dict['space']
  @set $dependentVariables = dict['dependentVariables']
  @set $componentCount = 0
  @for $variable in $dependentVariables
    @set $componentCount += len($variable.vector.components)
    @if $variable.vector.type == 'complex'
      @set $componentCount += len($variable.vector.components)
    @end if
  @end for
  @set dict['componentCount'] = componentCount
  @#

/* Create the group for this data */
hid_t group = H5Gcreate(hdf5_file, "/${groupID}", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);

fprintf($fp, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/${groupID}\"/>\n");
fprintf($fp, "%s\n", _dataFilename);
fprintf($fp, "    </Stream>\n");

/* Create the coordinate data sets */
hsize_t coordinate_length;
hid_t coordinate_dataspace;
  @for dim in field.dimensions
    @set $dimRep = dim.inSpace(space)
coordinate_length = ${dimRep.globalLattice};
coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
    @set $dataType = {'double': 'H5T_NATIVE_DOUBLE', 'long': 'H5T_NATIVE_LONG'}[$dimRep.type]
hid_t dataset_${dimRep.name} = H5Dcreate(hdf5_file, "/${groupID}/${dimRep.name}", ${dataType}, coordinate_dataspace, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
    @if not isinstance(dimRep, NonUniformDimensionRepresentation)
      @set $dimArrayName = c'${dimRep.name}_data'
${dimRep.type}* ${dimArrayName} = (${dimRep.type}*)xmds_malloc(${dimRep.globalLattice} * sizeof(${dimRep.type}));
for (long _i0 = 0; _i0 < ${dimRep.globalLattice}; _i0++) {
  ${dimArrayName}[_i0] = ${dimRep.minimum} + ${dimRep.stepSize} * _i0;
}
    @else
      @set $dimArrayName = dimRep.arrayName
    @end if
H5Dwrite(dataset_${dimRep.name}, $dataType, H5S_ALL, H5S_ALL, H5P_DEFAULT, ${dimArrayName});
H5DSset_scale(dataset_${dimRep.name}, "${dimRep.name}");

    @if not isinstance(dimRep, NonUniformDimensionRepresentation)
xmds_free(${dimArrayName});
    @end if
H5Sclose(coordinate_dataspace);
  @end for

hsize_t file_dims[] = {${', '.join(dim.inSpace(space).globalLattice for dim in field.dimensions)}};
hid_t file_dataspace;
file_dataspace = H5Screate_simple(${len(field.dimensions)}, file_dims, NULL);
  @for variable in dependentVariables
    @if $variable.vector.type == 'double'
      @set $variable['separatedComponents'] = list(enumerate($variable.components))
    @else
      @set $components = []
      @set variable['separatedComponents'] = components
      @for offset, componentName in enumerate($variable.components)
        @silent components.extend([(2*offset, componentName + 'R'), (2*offset+1, componentName + 'I')])
      @end for
    @end if
    @for offset, componentName in $variable.separatedComponents
hid_t dataset_${componentName} = H5Dcreate(hdf5_file, "/${groupID}/${componentName}", H5T_NATIVE_DOUBLE, file_dataspace, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
      @for dimNum, dim in enumerate(field.dimensions)
H5DSattach_scale(dataset_${componentName}, dataset_${dim.inSpace(space).name}, ${dimNum});
      @end for
    @end for
  @end for
  @for dim in field.dimensions
    @set $dimRep = dim.inSpace(space)
H5Dclose(dataset_${dimRep.name});
  @end for

  @# This is where all of the magic MPI code goes
  @set $featureOrdering = ['Driver']
  @set $featureDict = dict.copy()
  @set $featureDict['extraIndent'] = 0
${insertCodeForFeatures('binaryWriteOutWriteDataBegin', $featureOrdering, featureDict)}@slurp
  @set $extraIndent = featureDict['extraIndent']
  @silent dict['operation'] = 'write'
  @silent dict['variables'] = dict['dependentVariables']

${processData(dict), extraIndent=extraIndent}@slurp

  @# This is where the rest of the magic MPI code goes
${insertCodeForFeaturesInReverseOrder('binaryWriteOutWriteDataEnd', $featureOrdering, featureDict)}@slurp

  @for variable in dependentVariables
    @for offset, componentName in $variable.separatedComponents
H5Dclose(dataset_${componentName});
    @end for
  @end for

H5Sclose(file_dataspace);
H5Gclose(group);

  @#
@end def
