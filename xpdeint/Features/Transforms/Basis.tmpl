@*
Basis.tmpl

Created by Graham Dennis on 2008-12-14.
Copyright (c) 2008 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Features.Transforms._Basis

@def globalsForDim($dim)
  @#
  @set $forwardDimRep = dim.inSpace(0)
  @set $backwardDimRep = dim.inSpace(-1)
real *_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name};
real *_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name};
  @#
@end def

@def gridAndStepForDimRep($dimRep)
  @#
for (long _i0=0; _i0 < ${dimRep.globalLattice}; _i0++) {
  ${gridAndStepForDimRepAtIndex(dimRep, '_i0'), autoIndent=True}@slurp
}
  @#
@end def

@def gridAndStepForDimRepAtIndex($dimRep, $index)
  @#
${dimRep.arrayName}[$index] = ${gridForDimRepAtIndex(dimRep, index)};
${dimRep.stepSizeArrayName}[$index] = ${stepWeightForDimRepAtIndex(dimRep, index)};
  @#
@end def

@def transformMatricesForDimReps($forwardDimRep, $backwardDimRep)
_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name}  = (real *)xmds_malloc(sizeof(real) * ${forwardDimRep.globalLattice} * ${backwardDimRep.globalLattice});
_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name} = (real *)xmds_malloc(sizeof(real) * ${backwardDimRep.globalLattice} * ${forwardDimRep.globalLattice});
for (long _i0 = 0; _i0 < ${forwardDimRep.globalLattice}; _i0++) {
  ${transformMatricesForwardDimConstantsAtIndex(forwardDimRep, backwardDimRep, '_i0'), autoIndent=True}@slurp
  for (long _i1 = 0; _i1 < ${backwardDimRep.globalLattice}; _i1++) {
    ${transformMatricesForDimRepsAtIndices(forwardDimRep, backwardDimRep, '_i0', '_i1'), autoIndent=True}@slurp
  }
}
@end def

@def transformMatricesForwardDimConstantsAtIndex($forwardDimRep, $backwardDimRep, $index)
@end def

@def transformMatricesForDimRepsAtIndices($forwardDimRep, $backwardDimRep, $forwardIndex, $backwardIndex)
  @#
_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name} [${backwardIndex} * ${forwardDimRep.globalLattice} + ${forwardIndex}] = \
  ${forwardMatrixForDimAtIndices(forwardDimRep, backwardDimRep, forwardIndex, backwardIndex)};
_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name}[${forwardIndex} * ${backwardDimRep.globalLattice} + ${backwardIndex}] = \
  ${backwardMatrixForDimAtIndices(forwardDimRep, backwardDimRep, forwardIndex, backwardIndex)};
  @#
@end def

@def performTransform($sourceDimRep, $destDimRep, $dir = None)
  @#
  @set $matMultFunction = {'single': 'cblas_sgemm', 'double': 'cblas_dgemm'}[$precision]
${matMultFunction}(
  CblasRowMajor, CblasNoTrans, CblasNoTrans,
  ${destDimRep.globalLattice},
  /* nelem */ innerLoopSize,
  ${sourceDimRep.globalLattice},
  /* alpha */ 1.0,
  /* A */ _mmt_matrix_${sourceDimRep.name}_${destDimRep.name}, ${sourceDimRep.globalLattice},
  /* B */ source_data + _i0 * innerLoopSize * ${sourceDimRep.globalLattice},
          innerLoopSize,
  /* beta */ 0.0,
  /* C */ dest_data + _i0 * innerLoopSize * ${destDimRep.globalLattice},
  innerLoopSize
);
  @#
@end def

@def destroyTransformMatricesForDim($dim)
  @#
  @set $forwardDimRep = dim.inSpace(0)
  @set $backwardDimRep = dim.inSpace(-1)
xmds_free(_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name});
xmds_free(_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name});
  @#
@end def

@def transformFunctionStart($forwardDimRep, $backwardDimRep)
static real *_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name} = NULL;
static real *_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name} = NULL;
@end def

@def transformFunction(transformID, transformDict, function)
  @#
  @set $transformPair = transformDict['transformPair']
  @set $forwardDimRep = transformPair[0][0]
  @set $backwardDimRep = transformPair[1][0]
  @# FIXME: Change these names once we shift over to the new transform system
static bool _initialised = false;
${transformFunctionStart(forwardDimRep, backwardDimRep)}@slurp
ptrdiff_t innerLoopSize = _postfix_lattice;
real* const __restrict__ source_data = _data_in;
real* const __restrict__ dest_data = _data_out;

if (!_initialised) {
  _LOG(_SIMULATION_LOG_LEVEL, "Building matrices for ${function.description}...");
  
  ${transformMatricesForDimReps($forwardDimRep, $backwardDimRep), autoIndent=True}@slurp
  
  _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
  _initialised = true;
}

if (_forward) {
  for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
    ${performTransform(forwardDimRep, backwardDimRep, dir='forward'), autoIndent=True}@slurp
  }
} else {
  for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
    ${performTransform(backwardDimRep, forwardDimRep, dir='backward'), autoIndent=True}@slurp
  }
}
  @#
@end def
