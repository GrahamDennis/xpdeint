@*
FourierTransformFFTW3.tmpl

Created by Graham Dennis on 2007-08-23.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Features.Transforms._FourierTransformFFTW3

@def description: FFTW3

@attr $planType = "FFTW_MEASURE"

@def includes
  @#
  @super
  @#
#if (CFG_COMPILER == CFG_COMPILER_MSVC)
  #define FFTW_DLL
#endif

#define xmds_malloc ${fftwPrefix}_malloc
#define xmds_free ${fftwPrefix}_free

#include <fftw3.h>
@end def

@def globals
@*doc:
Return the string defining the globals needed by FFTW3.
*@
  @#
const real _inverse_sqrt_2pi = 1.0 / sqrt(2.0 * M_PI); 
string _fftwWisdomPath;
  @#
  @# The basic idea here is that in addition to the full forward/backward plans
  @# we should store plans for every other arbitrary space transform that we do.
  @# For the moment, these transforms will be generated during the simulation as
  @# they are needed. Because they are generated after initialisation, we can't
  @# use anything other than FFTW_ESTIMATE planning because FFTW_MEASURE and
  @# FFTW_PATIENT both overwrite the arrays in the testing process. Eventually
  @# this will be fixed by creating these plans as well at the start.
  @#
  @# So this code creates a map from (old_space, new_space) pairs to a
  @# _space_transform structure which describes the fourier transform(s) required
  @# for this operation. E.g. if you go from x ky z to kx y z, then you need two
  @# transforms, one forward transform to send x to kx, and one reverse transform
  @# to send ky to y. This is why there is both a _forward_plan and a 
  @# _backward_plan in the _space_transform structure.
  @#
typedef pair<unsigned long, unsigned long> _spaces_pair;

// Less than operator needed by the C++ map class
struct _spaces_pair_less_than
{
  bool operator()(const _spaces_pair& _x, const _spaces_pair& _y) const {
    return (_x.first < _y.first) || ((_x.first == _y.first) && (_x.second < _y.second));
  }
};

enum _transform_type {
  ${transformTypes, autoIndent=True}@slurp
};

typedef pair<${fftwPrefix}_plan, _transform_type> _plan_pair;
// Structure to hold the fourier transform plans for an arbitrary change of space
struct _space_transform
{
  vector<_plan_pair> _plans;
  real _c;
  
  _space_transform(real _c_in = 1.0) : _c(_c_in) {}
  
  _space_transform(const _space_transform& _s) : _plans(_s._plans), _c(_s._c) {}
  
  _space_transform(${fftwPrefix}_plan _p, _transform_type _t, real _c_in = 1.0) : _c(_c_in)
  {
    _plans.push_back(_plan_pair(_p, _t));
  }
  
  void append(const _space_transform& _s)
  {
    _c *= _s._c;
    _plans.insert(_plans.end(), _s._plans.begin(), _s._plans.end());
  }
};

// Map type for holding (old_space, new_space) -> _space_transform mappings
typedef map<_spaces_pair, _space_transform, _spaces_pair_less_than> _plan_map;

  @for $vector in $vectorsNeedingThisTransform
${planGlobalsForVector(vector)}@slurp
  @end for
@end def

@def transformFunction(transformID, transformDict, function)
  @#
  @set mpiPrefix, prefixLattice, postfixLattice = transformDict['transformSpecifier']
// _prefix_lattice should be ${prefixLattice}${''.join([' * ' + mpiLattice for mpiLattice in mpiPrefix])}
// _postfix_lattice should be ${postfixLattice}
static ${fftwPrefix}_plan _fftw_forward_plan = NULL;
static ${fftwPrefix}_plan _fftw_backward_plan = NULL;

if (!_fftw_forward_plan) {
  _LOG(_SIMULATION_LOG_LEVEL, "Planning for ${function.description}...");
  
  @set $transformPair = transformDict['transformPair']
  @set $dimensionsBeingTransformed = len(transformPair[0])
  @set $transformType = transformDict['transformType']
  ${fftwPrefix}_iodim _transform_sizes[${dimensionsBeingTransformed}], _loop_sizes[2];
  @if transformType == 'real'
  ${fftwPrefix}_r2r_kind _r2r_kinds[${dimensionsBeingTransformed}];
  @end if
  ${fftwPrefix}_iodim *_iodim_ptr = NULL;
  
  int _transform_sizes_index = 0, _loop_sizes_index = 0;
  
  if (_prefix_lattice) {
    _iodim_ptr = &_loop_sizes[_loop_sizes_index++];
    _iodim_ptr->n = _prefix_lattice;
    _iodim_ptr->is = _iodim_ptr->os = _postfix_lattice * ${' * '.join([dimRep.globalLattice for dimRep in transformPair[0]])};
  }
  if (_postfix_lattice) {
    _iodim_ptr = &_loop_sizes[_loop_sizes_index++];
    _iodim_ptr->n = _postfix_lattice;
    _iodim_ptr->is = _iodim_ptr->os = 1;
  }
  @#
  @for dimID, dimRep in enumerate(transformPair[0])
  _iodim_ptr = &_transform_sizes[_transform_sizes_index++];
  _iodim_ptr->n = ${dimRep.globalLattice};
  _iodim_ptr->is = _iodim_ptr->os = _postfix_lattice${''.join(c' * ${dr.globalLattice}' for dr in transformPair[0][dimID+1:])};
  
  @end for
  @#
  @if transformType == 'complex'
    @set $guruPlanFunction = self.createGuruDFTPlanInDirection
    @set $executeSuffix = 'dft'
    @set $reinterpretType = $fftwPrefix + '_complex'
  @else
    @set $guruPlanFunction = self.createGuruR2RPlanInDirection
    @set $executeSuffix = 'r2r'
    @set $reinterpretType = 'real'
  @end if
  @#
  @set $dataOut = '_data_out' if transformDict.get('outOfPlace', False) else '_data_in'
  @#
  ${guruPlanFunction(transformDict, 'forward', dataOut), autoIndent=True}@slurp
  ${guruPlanFunction(transformDict, 'backward', dataOut), autoIndent=True}@slurp
  
  // Save wisdom
  #if CFG_OSAPI == CFG_OSAPI_POSIX
  ${saveWisdom, autoIndent=True}@slurp
  #endif // POSIX
  
  _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
}

if (_forward) {
  ${fftwPrefix}_execute_${executeSuffix}(
    _fftw_forward_plan,
    reinterpret_cast<${reinterpretType}*>(_data_in),
    reinterpret_cast<${reinterpretType}*>(${dataOut})
  );
} else {
  ${fftwPrefix}_execute_${executeSuffix}(
    _fftw_backward_plan,
    reinterpret_cast<${reinterpretType}*>(_data_in),
    reinterpret_cast<${reinterpretType}*>(${dataOut})
  );
}
  @#
@end def

@def createGuruDFTPlanInDirection($transformDict, $direction, $dataOut)
  @#
_fftw_${direction}_plan = ${fftwPrefix}_plan_guru_dft(
  _transform_sizes_index, _transform_sizes,
  _loop_sizes_index, _loop_sizes,
  reinterpret_cast<${fftwPrefix}_complex*>(_data_in), reinterpret_cast<${fftwPrefix}_complex*>($dataOut),
  FFTW_${direction.upper()}, ${planType}
);
if (!_fftw_${direction}_plan)
  _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create ${direction} dft plan.\n", __FILE__, __LINE__);

  @#
@end def

@def createGuruR2RPlanInDirection($transformDict, $direction, $dataOut)
  @#
  @for idx, dimRep in enumerate(transformDict['transformPair'][0])
_r2r_kinds[${idx}] = ${r2rKindForDimensionAndDirection(dimRep.name, direction)};
  @end for

_fftw_${direction}_plan = ${fftwPrefix}_plan_guru_r2r(
  _transform_sizes_index, _transform_sizes,
  _loop_sizes_index, _loop_sizes,
  reinterpret_cast<real*>(_data_in), reinterpret_cast<real*>($dataOut),
  _r2r_kinds, ${planType}
);
if (!_fftw_${direction}_plan)
  _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create ${direction} r2r plan.\n", __FILE__, __LINE__);

  @#
@end def

@def transformTypes
  @#
_LOCAL_DFT_TRANSFORM
, _LOCAL_R2R_TRANSFORM
  @#
@end def

@def planGlobalsForVector($vector)
  @#
_plan_map _${vector.id}_plan_map;
  @#
@end def



@def mainBegin($dict)
// load wisdom and create plans for fft
#if CFG_OSAPI == CFG_OSAPI_POSIX // Don't load wisdom on windows
${loadWisdom}@slurp
#endif // POSIX
@end def


@def loadWisdom
  @#
char _hostName[256];
gethostname(_hostName, 256);
_hostName[255] = '\0'; // just in case

string _pathToWisdom = getenv("HOME");
_pathToWisdom += "/.xmds/wisdom/";

string _wisdomFileName = _hostName;
_wisdomFileName += ".wisdom";
_wisdomFileName += "${wisdomExtension}";

FILE *_fp = NULL;

_fp = fopen(_pathToWisdom.c_str(), "r");
if (_fp) {
  fclose(_fp);
} else {
  _LOG(_WARNING_LOG_LEVEL, "Warning: Cannot find enlightenment, the path to wisdom ~/.xmds/wisdom doesn't seem to exist.\n"
                           "         I'll use the current path instead.\n");
  _pathToWisdom = ""; // present directory
}

_fftwWisdomPath = _pathToWisdom + _wisdomFileName;

{
  FILE *_wisdomFile = NULL;
  if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "r")) != NULL) {
    _LOG(_SIMULATION_LOG_LEVEL, "Found enlightenment... (Importing wisdom)\n");
    ${fftwPrefix}_import_wisdom_from_file(_wisdomFile);
    fclose(_wisdomFile);
  }
}
  @#
@end def


@def saveWisdom
  @#
{
  FILE *_wisdomFile = NULL;
  if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "w")) != NULL) {
    ${fftwPrefix}_export_wisdom_to_file(_wisdomFile);
    fclose(_wisdomFile);
  }
}
  @#
@end def


@def mainEnd($dict)
  @#
${fftwPrefix}_cleanup();
  @#
@end def

