@*
FourierTransformFFTW3.tmpl

Created by Graham Dennis on 2007-08-23.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Features.Transforms._FourierTransformFFTW3

@def description: FFTW3

@attr $planType = "FFTW_MEASURE"
@attr $wisdomExtension = '.fftw3'
@attr $uselib = ['fftw3']

@def includes
  @#
  @super
  @#
#if (CFG_COMPILER == CFG_COMPILER_MSVC)
  #define FFTW_DLL
#endif

#include <fftw3.h>
#include <utility>
#include <map>
@end def

@def globals
@*doc:
Return the string defining the globals needed by FFTW3.
*@
  @#
const real _inverse_sqrt_2pi = 1.0 / sqrt(2.0 * M_PI); 
  @#
  @# The basic idea here is that in addition to the full forward/backward plans
  @# we should store plans for every other arbitrary space transform that we do.
  @# For the moment, these transforms will be generated during the simulation as
  @# they are needed. Because they are generated after initialisation, we can't
  @# use anything other than FFTW_ESTIMATE planning because FFTW_MEASURE and
  @# FFTW_PATIENT both overwrite the arrays in the testing process. Eventually
  @# this will be fixed by creating these plans as well at the start.
  @#
  @# So this code creates a map from (old_space, new_space) pairs to a
  @# _space_transform structure which describes the fourier transform(s) required
  @# for this operation. E.g. if you go from x ky z to kx y z, then you need two
  @# transforms, one forward transform to send x to kx, and one reverse transform
  @# to send ky to y. This is why there is both a _forward_plan and a 
  @# _backward_plan in the _space_transform structure.
  @#
typedef pair<unsigned long, unsigned long> _spaces_pair;

// Less than operator needed by the C++ map class
struct _spaces_pair_less_than
{
  bool operator()(const _spaces_pair& _x, const _spaces_pair& _y) const {
    return (_x.first < _y.first) || ((_x.first == _y.first) && (_x.second < _y.second));
  }
};

enum _transform_type {
  ${transformTypes, autoIndent=True}@slurp
};

typedef pair<fftw_plan, _transform_type> _plan_pair;
// Structure to hold the fourier transform plans for an arbitrary change of space
struct _space_transform
{
  vector<_plan_pair> _plans;
  real _c;
  
  _space_transform(real _c_in = 1.0) : _c(_c_in) {}
  
  _space_transform(const _space_transform& _s) : _plans(_s._plans), _c(_s._c) {}
  
  _space_transform(fftw_plan _p, _transform_type _t, real _c_in = 1.0) : _c(_c_in)
  {
    _plans.push_back(_plan_pair(_p, _t));
  }
  
  void append(const _space_transform& _s)
  {
    _c *= _s._c;
    _plans.insert(_plans.end(), _s._plans.begin(), _s._plans.end());
  }
};

// Map type for holding (old_space, new_space) -> _space_transform mappings
typedef map<_spaces_pair, _space_transform, _spaces_pair_less_than> _plan_map;

  @for $vector in $vectorsNeedingThisTransform
${planGlobalsForVector(vector)}@slurp
  @end for
@end def

@def transformTypes
  @#
_LOCAL_DFT_TRANSFORM
, _LOCAL_R2R_TRANSFORM
  @#
@end def

@def planGlobalsForVector($vector)
  @#
_plan_map _${vector.id}_plan_map;
  @#
@end def



@def mainBegin($dict)
// load wisdom and create plans for fft
#if CFG_OSAPI == CFG_OSAPI_POSIX // Don't load wisdom on windows
${loadWisdom}@slurp
#endif // POSIX

_LOG(_SIMULATION_LOG_LEVEL, "Making FFTW plans\n");

  @#
  @# Some of the vectors that we need to create plans for may be temporary vectors,
  @# and hence will not be allocated yet.
  @# The solution is to work out the largest of these vectors, allocate space for that,
  @# and use that to create the plans. Unless we can use another vector that we have
  @# already allocated.
  @#
  @set $temporaryVectorsNeedingFourierTransforms = [v for v in $vectorsNeedingThisTransform if v in v.field.temporaryVectors]
  @set $managedVectorsNeedingFourierTransforms = [v for v in $vectorsNeedingThisTransform if v in v.field.managedVectors]
  @if temporaryVectorsNeedingFourierTransforms
    @# We have vectors that need something to be allocated
    @set $temporaryVectorSizes = [(vector.maxSizeInReals, vector) for vector in temporaryVectorsNeedingFourierTransforms]
    @set $managedVectorSizes = [(vector.maxSizeInReals, vector) for vector in managedVectorsNeedingFourierTransforms]
    @set $maxTemporaryVectorAndSize = max(temporaryVectorSizes)
    @if managedVectorSizes
      @set $maxManagedVectorAndSize = max(managedVectorSizes)
    @else
      @set $maxManagedVectorAndSize = (0, None)
    @end if
    @#
    @# If the maximum temporary vector is bigger than the maximum managed vector, then we really do need to allocate an array
    @if $maxTemporaryVectorAndSize[0] > $maxManagedVectorAndSize[0]
      @set $maxVector = $maxTemporaryVectorAndSize[1]
      @set $allocatedTemporaryVector = True

// allocate an array so we can create plans for those vectors that we have not allocated yet
real* _temporary_vector = (real*) xmds_malloc(sizeof(${maxVector.type}) * ${maxVector.allocSize});
    @else
      @# The maximum managed vector is larger than the maximum temporary vector, so there's no point in allocating an array
      @set $allocatedTemporaryVector = False
      @set $maxVector = $maxManagedVectorAndSize[1]
      
// just use the _${maxVector.id} array for creating plans for those vectors that we have not allocated yet
real* _temporary_vector = (real*)_${maxVector.id};
    @end if
  @end if

fftw_plan _plan;
fftw_iodim _forward_sizes[${len($geometry.dimensions)}], _forward_loop_sizes[${len($geometry.dimensions) + 1}];
fftw_iodim _backward_sizes[${len($geometry.dimensions)}], _backward_loop_sizes[${len($geometry.dimensions) + 1}];
fftw_iodim _r2r_sizes[${len($geometry.dimensions)}], _r2r_loop_sizes[${len($geometry.dimensions) + 1}];
fftw_iodim *_forward_iodim_ptr = NULL, *_backward_iodim_ptr = NULL, *_r2r_iodim_ptr;
fftw_r2r_kind _r2r_kinds[${len($geometry.dimensions)}];

int _forward_sizes_index, _backward_sizes_index, _r2r_sizes_index;
int _forward_loop_sizes_index, _backward_loop_sizes_index, _r2r_loop_sizes_index;
real _c;

_space_transform *_transform;
  @#
  @for vector in $vectorsNeedingThisTransform

// Plans for vector ${vector.name}
${createGuruPlansForVector(vector)}@slurp
  @end for
  @#
  @if $temporaryVectorsNeedingFourierTransforms and $allocatedTemporaryVector
xmds_free(_temporary_vector);
_temporary_vector = NULL;

  @end if
#if CFG_OSAPI == CFG_OSAPI_POSIX // Don't load wisdom on windows
${saveWisdom}@slurp
#endif // POSIX

_LOG(_SIMULATION_LOG_LEVEL, "FFTW planning complete\n");
@end def


@def loadWisdom
  @#
char _hostName[256];
gethostname(_hostName, 256);
_hostName[255] = '\0'; // just in case

string _pathToWisdom = getenv("HOME");
_pathToWisdom += "/.xmds/wisdom/";

string _wisdomFileName = _hostName;
_wisdomFileName += ".wisdom";
_wisdomFileName += "${wisdomExtension}";

FILE *_fp = NULL;

_fp = fopen(_pathToWisdom.c_str(), "r");
if (_fp) {
  fclose(_fp);
} else {
  _LOG(_WARNING_LOG_LEVEL, "Warning: Cannot find enlightenment, the path to wisdom ~/.xmds/wisdom doesn't seem to exist.\n"
                           "         I'll use the current path instead.\n");
  _pathToWisdom = ""; // present directory
}

string _wisdomPath = _pathToWisdom + _wisdomFileName;

FILE *_wisdomFile = NULL;

if ( (_wisdomFile = fopen(_wisdomPath.c_str(), "r")) != NULL) {
  _LOG(_SIMULATION_LOG_LEVEL, "Found enlightenment... (Importing wisdom)\n");
  fftw_import_wisdom_from_file(_wisdomFile);
  fclose(_wisdomFile);
}
  @#
@end def


@def saveWisdom
  @#
if ( (_wisdomFile = fopen(_wisdomPath.c_str(), "w")) != NULL) {
  _LOG(_SIMULATION_LOG_LEVEL, "Keeping accumulated wisdom\n");
  fftw_export_wisdom_to_file(_wisdomFile);
  fclose(_wisdomFile);
}
  @#
@end def


@def createGuruPlansForVector($vector)
  @#
  @set $dimensions = [dim for dim in vector.field.dimensions if not dim.isDistributed]
  @set $blankLineSeparator = ''
  @#
  @if vector.type == 'real'
    @set $r2rMultiplier = 1
  @else
    @set $r2rMultiplier = 2
  @end if
  @set $spacesNeeded = set([space & $transformMask for space in vector.spacesNeeded])
  @set $numberOfSpacesNeeded = len(spacesNeeded)
unsigned long _spaces_needed_for_${vector.id}[] = {${', '.join([str(space) for space in spacesNeeded])}};

for (int _from_space_index = 0; _from_space_index < ${numberOfSpacesNeeded}; _from_space_index++) {
  const unsigned long _the_from_space = _spaces_needed_for_${vector.id}[_from_space_index];
  for (int _to_space_index = 0; _to_space_index < ${numberOfSpacesNeeded}; _to_space_index++) {
    unsigned long _from_space = _the_from_space;
    const unsigned long _to_space = _spaces_needed_for_${vector.id}[_to_space_index];
    if (_from_space == _to_space)
      continue;
    
    _forward_sizes_index = _backward_sizes_index = _r2r_sizes_index = 0;
    _forward_loop_sizes_index = _backward_loop_sizes_index = _r2r_loop_sizes_index = 0;
    _plan = NULL;
    
    _${vector.id}_plan_map[_spaces_pair(_from_space, _to_space)] = _space_transform(1.0);
    
    _transform = &_${vector.id}_plan_map[_spaces_pair(_from_space, _to_space)];
    
  @# This is where to put code to modify the way local transforms are produced
  @# when we have MPI transforms too
  @if $vector.field.isDistributed
    _forward_iodim_ptr = &_forward_loop_sizes[_forward_loop_sizes_index++];
    _backward_iodim_ptr = &_backward_loop_sizes[_backward_loop_sizes_index++];
    _r2r_iodim_ptr = &_r2r_loop_sizes[_r2r_loop_sizes_index++];
    
    _forward_iodim_ptr->n  = ${' * '.join([dim.inSpace('_from_space').localLattice for dim in vector.field.dimensions if dim.isDistributed])};
    @set $indices = [i for i, dim in enumerate(vector.field.dimensions) if not dim.isDistributed]
    _forward_iodim_ptr->is = _${vector.id}_ncomponents * ${vector.field.pointsInDimensionsWithIndices(indices)};
    
    _backward_iodim_ptr->n  = _r2r_iodim_ptr->n = _forward_iodim_ptr->n;
    _backward_iodim_ptr->os = _forward_iodim_ptr->os = _backward_iodim_ptr->is = _forward_iodim_ptr->is;
    
    _r2r_iodim_ptr->os =_r2r_iodim_ptr->is = ${r2rMultiplier}*_forward_iodim_ptr->is;
    
    ${setupLocalTransformsForVector(vector), autoIndent=True}@slurp
  @end if
  @#
  @for dimension in dimensions
    @# All spaces are defined relative to the dimension ordering in the geometry
    @set $bitMask = dimension.transformMask
    
    // Set sizes for transforms in dimension '$dimension.name'
    _forward_iodim_ptr = _backward_iodim_ptr = _r2r_iodim_ptr = NULL;
    @if $transformNameMap.get(dimension.name) in ['dct', 'dst', 'dft']
    if ( !(_from_space & ${bitMask}) && (_to_space & ${bitMask})) {
      // Forward ${transformNameMap[dimension.name]} transform for '$dimension.name'
      @if $transformNameMap[dimension.name] == 'dft'
      _forward_iodim_ptr = &_forward_sizes[_forward_sizes_index++];
      @else
      _r2r_iodim_ptr = &_r2r_sizes[_r2r_sizes_index];
      _r2r_kinds[_r2r_sizes_index++] = ${r2rKindForDimensionAndDirection(dimension, 'forward')};
      @end if
      _transform->_c *= ${dimension.inSpace(0).stepSize} * _inverse_sqrt_2pi;
    } else if ( (_from_space & ${bitMask}) && !(_to_space & ${bitMask}) ) {
      // Backward ${transformNameMap[dimension.name]} transform for '$dimension.name'
      @if $transformNameMap[dimension.name] == 'dft'
      _backward_iodim_ptr = &_backward_sizes[_backward_sizes_index++];
      @else
      _r2r_iodim_ptr = &_r2r_sizes[_r2r_sizes_index];
      _r2r_kinds[_r2r_sizes_index++] = ${r2rKindForDimensionAndDirection(dimension, 'backward')};
      @end if
      _transform->_c *= ${dimension.inSpace(-1).stepSize} * _inverse_sqrt_2pi;
    }
    @end if
    // if any pointers aren't set, they must be a loop
    if (!_forward_iodim_ptr) _forward_iodim_ptr = &_forward_loop_sizes[_forward_loop_sizes_index++];
    if (!_backward_iodim_ptr) _backward_iodim_ptr = &_backward_loop_sizes[_backward_loop_sizes_index++];
    if (!_r2r_iodim_ptr) _r2r_iodim_ptr = &_r2r_loop_sizes[_r2r_loop_sizes_index++];
    
    _forward_iodim_ptr->n  = ${dimension.inSpace(0).localLattice};
    @set $fieldDimensionNumber = $vector.field.indexOfDimension(dimension)
    _forward_iodim_ptr->is = _${vector.id}_ncomponents * ${vector.field.pointsInDimensionsWithIndices(range($fieldDimensionNumber + 1, len($vector.field.dimensions)))};
    
    _backward_iodim_ptr->n  = _r2r_iodim_ptr->n = _forward_iodim_ptr->n;
    _backward_iodim_ptr->os = _forward_iodim_ptr->os = _backward_iodim_ptr->is = _forward_iodim_ptr->is;
    
    _r2r_iodim_ptr->os = _r2r_iodim_ptr->is = ${r2rMultiplier}*_forward_iodim_ptr->is;
  @end for
    
    // Now the 'components' dimension
    if (_${vector.id}_ncomponents > 1) {
      _forward_iodim_ptr  = &_forward_loop_sizes[_forward_loop_sizes_index++];
      _backward_iodim_ptr = &_backward_loop_sizes[_backward_loop_sizes_index++];
      _r2r_iodim_ptr      = &_r2r_loop_sizes[_r2r_loop_sizes_index++];
      
      _forward_iodim_ptr->n  = _${vector.id}_ncomponents;
      _forward_iodim_ptr->os = _forward_iodim_ptr->is = 1;
      
      _backward_iodim_ptr->n  = _forward_iodim_ptr->n;
      _r2r_iodim_ptr->n = ${r2rMultiplier}*_forward_iodim_ptr->n;
      _backward_iodim_ptr->os = _r2r_iodim_ptr->os = _forward_iodim_ptr->os = _backward_iodim_ptr->is = _r2r_iodim_ptr->is = _forward_iodim_ptr->is;
    }
  @if r2rMultiplier > 1
    else {
      // r2r transforms still require a loop
      _r2r_iodim_ptr = &_r2r_loop_sizes[_r2r_loop_sizes_index++];
      _r2r_iodim_ptr->n  = ${r2rMultiplier};
      _r2r_iodim_ptr->os = _r2r_iodim_ptr->is = 1;
    }
  @end if
    
  @#
    if (_forward_sizes_index) {
      // If we have dimensions needing forward transforms, then we need a forward fft plan
      ${createGuruDFTPlanForVector($vector, 'forward'), autoIndent=True}@slurp
    }
    if (_backward_sizes_index) {
      // If we have some dimensions needing backward transforms, then we need a backward fft plan
      ${createGuruDFTPlanForVector($vector, 'backward'), autoIndent=True}@slurp
    }
    if (_r2r_sizes_index) {
      // If we have some dimensions needing r2r transforms, then we need a r2r plan
      ${createGuruR2RPlanForVector($vector), autoIndent=True}@slurp
    }
  }
}

  @#
@end def

@def setupLocalTransformsForVector($vector)
  @#
  @if not $_driver.hasattr('distributedTransform')
    @return
  @end if
  @#
@end def


@def mainEnd($dict)
  @#
  
// destroy plans and save wisdom
  @for vector in $vectorsNeedingThisTransform
_${vector.id}_plan_map.clear(); // This doesn't actually destroy the fftw_plan objects
  @end for

fftw_cleanup();
  @#
@end def

@def goSpaceFunctionContentsForVector($function, $vector)
@*doc:
Returns the ``go_space`` function implementation for vector `vector`.

This writes the function that does the fourier transforming of a specific vector
to and from arbitrary combinations of fourier-space and normal-space.
*@
  @#
real _c = 1.0;

if (_${vector.id}_plan_map.count(_spaces_pair(_currentSpace, _newSpace)) == 0) {
  _LOG(_ERROR_LOG_LEVEL, "Error: We should have plans for every required transform, but it seems we don't for this transform.\n"
                         "       The transform is for the vector '${vector.id}' from space %li to space %li.\n",
                         _currentSpace, _newSpace);
}

_space_transform& _transform = _${vector.id}_plan_map[_spaces_pair(_currentSpace, _newSpace)];
if (_transform._plans.size() == 0) {
  _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                         "       The transform was for the vector '${vector.id}' from space %li to space %li.\n",
                         _currentSpace, _newSpace);
}


for (vector<_plan_pair>::iterator _it = _transform._plans.begin(); _it != _transform._plans.end(); ++_it) {
  switch(_it->second) {
    ${executePlanForVector(vector), autoIndent=True}@slurp
    default:
      _LOG(_ERROR_LOG_LEVEL, "Unknown plan type: %i\n", _it->second);
  }
}
_c = _transform._c;

${loopOverVectorsWithInnerContentTemplate([$vector], '_active_${vector.id}[$index] *= _c;')}@slurp
  @#
@end def

@def executePlanForVector($vector)
  @#
case _LOCAL_DFT_TRANSFORM:
  fftw_execute_dft(_it->first, reinterpret_cast<fftw_complex*>(_active_${vector.id}),
                               reinterpret_cast<fftw_complex*>(_active_${vector.id}));
  break;
case _LOCAL_R2R_TRANSFORM:
  fftw_execute_r2r(_it->first, reinterpret_cast<real*>(_active_${vector.id}),
                               reinterpret_cast<real*>(_active_${vector.id}));
  break;
  @#
@end def


@def createGuruDFTPlanForVector($vector, $type)
@*doc:
Return the FFTW3 'guru' plan creation call needed for this arbitrary transform.
*@
  @#
  @set $arrayName = c'_${vector.id}'
  @if vector in vector.field.temporaryVectors
    @set $arrayName = '_temporary_vector'
  @end if
  @#
_plan = fftw_plan_guru_dft(_${type}_sizes_index, _${type}_sizes,
                           _${type}_loop_sizes_index, _${type}_loop_sizes,
                           reinterpret_cast<fftw_complex*>(${arrayName}),
                           reinterpret_cast<fftw_complex*>(${arrayName}),
                           FFTW_${type.upper()}, ${planType});

_transform->_plans.push_back(_plan_pair(_plan, _LOCAL_DFT_TRANSFORM));
  @#
@end def

@def createGuruR2RPlanForVector($vector)
  @#
  @set $arrayName = c'_${vector.id}'
  @if vector in vector.field.temporaryVectors
    @set $arrayName = '_temporary_vector'
  @end if
  @#
_plan = fftw_plan_guru_r2r(_r2r_sizes_index, _r2r_sizes,
                           _r2r_loop_sizes_index, _r2r_loop_sizes,
                           reinterpret_cast<real*>(${arrayName}),
                           reinterpret_cast<real*>(${arrayName}),
                           _r2r_kinds, ${planType});

_transform->_plans.push_back(_plan_pair(_plan, _LOCAL_R2R_TRANSFORM));
  @#
@end def

