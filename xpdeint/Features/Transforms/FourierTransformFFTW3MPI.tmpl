@*
FourierTransformFFTW3MPI.tmpl

Created by Graham Dennis on 2008-06-06.
Copyright (c) 2008 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Features.Transforms._FourierTransformFFTW3MPI
@import operator
@from xpdeint.Geometry.UniformDimensionRepresentation import UniformDimensionRepresentation
@from xpdeint.Geometry.SplitUniformDimensionRepresentation import SplitUniformDimensionRepresentation

@def description: FFTW3 with MPI
@attr $fftwSuffix = 'mpi'

@def includes
  @#
  @super
  @#
#include <fftw3-mpi.h>
@end def

@def globals
  @#
  @super
  @#
ptrdiff_t _unswapped_block_size = 0;
ptrdiff_t _swapped_block_size = 0;
  @#
@end def

@def setLocalLatticeAndOffsetVariables
  @#
// First work out the local lattice and offset for the geometry
  @set $firstMPIDim = $mpiDimensions[0]
  @set $secondMPIDim = $mpiDimensions[1]
  @set $fullTransformDimensions = $fullTransformDimensionsForField($geometry)
ptrdiff_t _sizes[] = {${', '.join([dim.inSpace(0).globalLattice for dim in fullTransformDimensions])}};

  @set $indices = range($geometry.indexOfDimension(fullTransformDimensions[-1])+1, len($geometry.dimensions))
ptrdiff_t _howmany = ((ptrdiff_t)1) * ${geometry.pointsInDimensionsWithIndices(indices)};
ptrdiff_t _local_alloc_size;

${fftwPrefix}_mpi_init();
_local_alloc_size = ${fftwPrefix}_mpi_local_size_many_transposed(${len(fullTransformDimensions)}, _sizes, _howmany,
                                                        FFTW_MPI_DEFAULT_BLOCK, FFTW_MPI_DEFAULT_BLOCK, MPI_COMM_WORLD,
                                                        &${firstMPIDim.inSpace(0).localLattice}, &${firstMPIDim.inSpace(0).localOffset},
                                                        &${secondMPIDim.inSpace($swappedSpace).localLattice}, &${secondMPIDim.inSpace($swappedSpace).localOffset});
  @# Set the transformed, but unswapped variables for the first dimension
${firstMPIDim.inSpace($firstMPIDim.transformMask).localLattice} = ${firstMPIDim.inSpace(0).localLattice};
${firstMPIDim.inSpace($firstMPIDim.transformMask).localOffset} = ${firstMPIDim.inSpace(0).localOffset};
${secondMPIDim.representations[2].localLattice} = ${secondMPIDim.inSpace($swappedSpace).localLattice};
${secondMPIDim.representations[2].localOffset} = ${secondMPIDim.inSpace($swappedSpace).localOffset};

if (_rank == 0) {
  _unswapped_block_size = ${firstMPIDim.inSpace(0).localLattice};
  _swapped_block_size = ${secondMPIDim.inSpace($swappedSpace).localLattice};
}
MPI_Bcast(&_unswapped_block_size, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);
MPI_Bcast(&_swapped_block_size, sizeof(ptrdiff_t), MPI_BYTE, 0, MPI_COMM_WORLD);

  @for $field in $fields
    @if field.name == 'geometry' or not $field.isDistributed
      @continue
    @end if
    @#
    @# Set the local_lattice and local_offset variables based on the
    @# values for the geometry's version of these
    @set $fieldMPIDim1 = field.dimensionWithName(firstMPIDim.name)
    @set $fieldMPIDim2 = field.dimensionWithName(secondMPIDim.name)
// Set the local lattice and offset variables for the '${field.name}' field
    @if fieldMPIDim1 == firstMPIDim and fieldMPIDim2 == secondMPIDim
      @# The field has the same structure for these dimensions as the geometry
      @for dimOut, dimIn in [(fieldMPIDim1, firstMPIDim), (fieldMPIDim2, secondMPIDim)]
        @for repOut, repIn in zip(dimOut.representations, dimIn.representations)
          @if repOut and repOut.hasLocalOffset and repOut.parent is fieldMPIDim1
${repOut.localLattice} = ${repIn.localLattice};
${repOut.localOffset} = ${repIn.localOffset};
          @end if
        @end for
      @end for
      @if all([dim.isTransformable for dim in [fieldMPIDim1, fieldMPIDim2]])
        @# Set the alloc size variable through an actual call to local_size_many_transposed
        @set $indices = range(len(field.dimensions))
        @for dim in [fieldMPIDim1, fieldMPIDim2]
          @silent indices.remove(field.indexOfDimension(dim))
        @end for
_howmany = ((ptrdiff_t)1) * ${field.pointsInDimensionsWithIndices(indices)};
${field.allocSize} = ${fftwPrefix}_mpi_local_size_many_transposed(2, _sizes, _howmany, _unswapped_block_size, _swapped_block_size, MPI_COMM_WORLD,
        &${fieldMPIDim1.inSpace(0).localLattice}, &${fieldMPIDim1.inSpace(0).localOffset},
        &${fieldMPIDim2.inSpace($swappedSpace).localLattice}, &${fieldMPIDim2.inSpace($swappedSpace).localOffset});
        @if any([dimRep.parent is mpiDim for mpiDim in [fieldMPIDim1, fieldMPIDim2] for dimRep in mpiDim.representations])
if (   (${fieldMPIDim1.inSpace(0).localLattice} != ${firstMPIDim.inSpace(0).localLattice})
    || (${fieldMPIDim1.inSpace(0).localOffset} != ${firstMPIDim.inSpace(0).localOffset})
    || (${fieldMPIDim2.inSpace($swappedSpace).localLattice} != ${secondMPIDim.inSpace($swappedSpace).localLattice})
    || (${fieldMPIDim2.inSpace($swappedSpace).localOffset} != ${secondMPIDim.inSpace($swappedSpace).localOffset})) {
  _LOG(_ERROR_LOG_LEVEL, "Local lattice/offset values returned for field '$field.name' aren't the same as the values for the full transform.\n"
                         "Please report this error and the script that caused it to ${bugReportAddress}\n"
                         "Number of nodes: %i\n"
                         "${firstMPIDim.inSpace(0).localLattice}: %ti\n"
                         "${firstMPIDim.inSpace(0).localOffset}: %ti\n"
                         "${fieldMPIDim1.inSpace(0).localLattice}: %ti\n"
                         "${fieldMPIDim1.inSpace(0).localOffset}: %ti\n"
                         "${secondMPIDim.inSpace($swappedSpace).localLattice}: %ti\n"
                         "${secondMPIDim.inSpace($swappedSpace).localOffset}: %ti\n"
                         "${fieldMPIDim2.inSpace($swappedSpace).localLattice}: %ti\n"
                         "${fieldMPIDim2.inSpace($swappedSpace).localOffset}: %ti\n",
                         _size, ${firstMPIDim.inSpace(0).localLattice}, ${firstMPIDim.inSpace(0).localOffset},
                         ${fieldMPIDim1.inSpace(0).localLattice}, ${fieldMPIDim1.inSpace(0).localOffset},
                         ${secondMPIDim.inSpace($swappedSpace).localLattice}, ${secondMPIDim.inSpace($swappedSpace).localOffset},
                         ${fieldMPIDim2.inSpace($swappedSpace).localLattice}, ${fieldMPIDim2.inSpace($swappedSpace).localOffset});
}
        @end if
      @else
              @set $fieldIndices = range(0, len(field.dimensions))
              @silent fieldIndices.remove(field.indexOfDimension(firstMPIDim))
              @silent fieldIndices.remove(field.indexOfDimension(secondMPIDim))
              @set $geometryIndices = range(1, len($geometry.dimensions))
              @silent geometryIndices.remove($geometry.indexOfDimension(firstMPIDim))
              @silent geometryIndices.remove($geometry.indexOfDimension(secondMPIDim))
${field.allocSize} = _local_alloc_size * ${field.pointsInDimensionsWithIndices(fieldIndices)} / (${geometry.pointsInDimensionsWithIndices(geometryIndices)});
      @end if
    @else
      @# The field has different structure to the geometry, so we need to work out our local offsets and lattice sizes.
      @for fieldDim, mpiDim in [(fieldMPIDim1, firstMPIDim), (fieldMPIDim2, secondMPIDim)]
        @if fieldDim == mpiDim
          @# This dimension matches.
          @for repOut, repIn in zip(fieldDim.representations, mpiDim.representations)
            @if repOut and repOut.hasLocalOffset
${repOut.localLattice} = ${repIn.localLattice};
${repOut.localOffset} = ${repIn.localOffset};
            @end if
          @end for
        @else
          @# The dimensions aren't the same.
          @for fieldRep, geometryRep in zip(fieldDim.representations, mpiDim.representations)
            @if not fieldRep or not fieldRep.hasLocalOffset
              @continue
            @end if
            @if fieldRep.reductionMethod == fieldDim.ReductionMethod.fixedRange
              @# In this case we are in 'x' space and are subdividing a distributed dimension
ptrdiff_t _${field.name}_unswapped_skip_size = ${geometryRep.globalLattice}/${fieldRep.globalLattice};
if (_rank == 0) {
  ${fieldRep.localOffset}  = 0;
  ${fieldRep.localLattice} = (${geometryRep.localLattice}-1)/_${field.name}_unswapped_skip_size + 1;
} else {
  ${fieldRep.localOffset}  = (${geometryRep.localOffset}-1)/_${field.name}_unswapped_skip_size + 1;
  ${fieldRep.localLattice} = (${geometryRep.localOffset} + ${geometryRep.localLattice} - 1)/_${field.name}_unswapped_skip_size
                             + 1 - ${fieldRep.localOffset};
}
            @elif isinstance(fieldRep, UniformDimensionRepresentation)
              @# In this case, we are in 'k' space and may be subdividing a UniformDimensionRepresentation (dct/dst)
if (${geometryRep.localOffset} >= ${fieldRep.globalLattice}) {
  // No points here
  ${fieldRep.localOffset} = 0;
  ${fieldRep.localLattice} = 0;
} else if (${geometryRep.localOffset} + ${geometryRep.localLattice} > ${fieldRep.globalLattice}){
  // The upper edge is here
  ${fieldRep.localOffset} = ${geometryRep.localOffset};
  ${fieldRep.localLattice} = ${fieldRep.globalLattice} - ${geometryRep.localOffset};
} else {
  // somewhere near the start
  ${fieldRep.localOffset} = ${geometryRep.localOffset};
  ${fieldRep.localLattice} = ${geometryRep.localLattice};
}
            @elif isinstance(fieldRep, SplitUniformDimensionRepresentation)
              @# In this case, we are in 'k' space and may be subdividing a SplitUniformDimensionRepresentation (dft)
${fieldRep.localOffset} = -1;
if (${geometryRep.localOffset} >= (${fieldRep.globalLattice}+1)/2) {
  // No points due to positive 'k' values.
} else if (${geometryRep.localOffset} + ${geometryRep.localLattice} > (${fieldRep.globalLattice}+1)/2) {
  // the upper edge of the positive values are here
  ${fieldRep.localOffset} = ${geometryRep.localOffset};
  ${fieldRep.localLattice} = (${fieldRep.globalLattice}+1)/2 - ${geometryRep.localOffset};
} else if (${geometryRep.localOffset} < (${fieldRep.globalLattice}+1)/2) {
  // somewhere near the start of the positive values
  ${fieldRep.localOffset} = ${geometryRep.localOffset};
  ${fieldRep.localLattice} = ${geometryRep.localLattice};
}

if (${geometryRep.localOffset} + ${geometryRep.localLattice} <= ${geometryRep.globalLattice} - ${fieldRep.globalLattice}/2) {
  // No points due to negative 'k' values.
} else if (${geometryRep.localOffset} < ${geometryRep.globalLattice} - ${fieldRep.globalLattice}/2) {
  // the lower edge of the negative values are here
  if (${fieldRep.localOffset} == -1)
    ${fieldRep.localOffset} = (${fieldRep.globalLattice}+1)/2;
  ${fieldRep.localLattice} += ${geometryRep.localLattice} - (${geometryRep.globalLattice}-${fieldRep.globalLattice}/2-${geometryRep.localOffset});
} else if (${geometryRep.localOffset} + ${geometryRep.localLattice} > ${geometryRep.globalLattice} - ${fieldRep.globalLattice}/2) {
  // somewhere near the end of the negative values
  ${fieldRep.localOffset} = ${geometryRep.localOffset} - (${geometryRep.globalLattice}-${fieldRep.globalLattice});
  ${fieldRep.localLattice} = ${geometryRep.localLattice};
}
            @end if
          @end for
        @end if
      @end for
ptrdiff_t _${field.name}_2d_size = 0;
      @for spaceID in range(4)
        @set $space = 0
        @if spaceID & 1
          @set $space |= $firstMPIDim.transformMask
        @end if
        @if spaceID & 2
          @set $space |= $secondMPIDim.transformMask
        @end if
        @set $fieldRep1 = $fieldMPIDim1.inSpace(space)
        @set $fieldRep2 = $fieldMPIDim2.inSpace(space)
        @if not fieldRep1 or not fieldRep2
          @continue
        @end if
_${field.name}_2d_size = MAX(_${field.name}_2d_size, ${fieldRep1.localLattice} * ${fieldRep2.localLattice});
      @end for
      @set $indices = range(len(field.dimensions))
      @silent indices.remove(field.indexOfDimension(firstMPIDim))
      @silent indices.remove(field.indexOfDimension(secondMPIDim))
${field.allocSize} = _${field.name}_2d_size * ${field.pointsInDimensionsWithIndices(indices)};
    @end if
  @end for
  @#
@end def

@def transposeTransformFunction(transformID, transformDict, function)
  @#
  @set mpiPrefix, prefixLattice, postfixLattice = transformDict['transformSpecifier']
// _prefix_lattice should be ${prefixLattice}
// _postfix_lattice should be ${postfixLattice}
static ${fftwPrefix}_plan _fftw_forward_plan = NULL;
static ${fftwPrefix}_plan _fftw_backward_plan = NULL;

if (!_fftw_forward_plan) {
  _LOG(_SIMULATION_LOG_LEVEL, "Planning for ${function.description}...");
  @set $transformPair = transformDict['transformPair']
  @set $dataOut = '_data_out' if transformDict.get('outOfPlace', False) else '_data_in'
  
  _fftw_forward_plan = ${fftwPrefix}_mpi_plan_many_transpose(
    ${', '.join(dr.globalLattice for dr in transformPair[0])},
    _postfix_lattice, _unswapped_block_size, _swapped_block_size,
    reinterpret_cast<real*>(_data_in),
    reinterpret_cast<real*>($dataOut),
    MPI_COMM_WORLD, ${planType}
  );
  
  if (!_fftw_forward_plan)
    _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create forward mpi transform plan.\n", __FILE__, __LINE__);
  
  _fftw_backward_plan = ${fftwPrefix}_mpi_plan_many_transpose(
    ${', '.join(dr.globalLattice for dr in transformPair[1])},
    _postfix_lattice, _swapped_block_size, _unswapped_block_size,
    reinterpret_cast<real*>(_data_in),
    reinterpret_cast<real*>($dataOut),
    MPI_COMM_WORLD, ${planType}
  );
  
  if (!_fftw_backward_plan)
    _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create backward mpi transform plan.\n", __FILE__, __LINE__);
  
  // Save wisdom
  #if CFG_OSAPI == CFG_OSAPI_POSIX
  ${saveWisdom, autoIndent=True}@slurp
  #endif // POSIX
  
  _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
}

if (_forward) {
  ${fftwPrefix}_execute_r2r(
    _fftw_forward_plan,
    reinterpret_cast<real*>(_data_in),
    reinterpret_cast<real*>(${dataOut})
  );
} else {
  ${fftwPrefix}_execute_r2r(
    _fftw_backward_plan,
    reinterpret_cast<real*>(_data_in),
    reinterpret_cast<real*>(${dataOut})
  );
}
  @#
@end def

@def distributedTransformFunction(transformID, transformDict, function)
  @#
  @set mpiPrefix, prefixLattice, postfixLattice = transformDict['transformSpecifier']
// _prefix_lattice should be ${prefixLattice}
// _postfix_lattice should be ${postfixLattice}
static ${fftwPrefix}_plan _fftw_forward_plan = NULL;
static ${fftwPrefix}_plan _fftw_backward_plan = NULL;

if (!_fftw_forward_plan) {
  _LOG(_SIMULATION_LOG_LEVEL, "Planning for ${function.description}...");
  @set $transformPair = transformDict['transformPair']
  @set $dimensionsBeingTransformed = len(transformPair[0])
  @set $transformType = transformDict['transformType']
  @set $dataOut = '_data_out' if transformDict.get('outOfPlace', False) else '_data_in'
  ptrdiff_t _transform_sizes[${dimensionsBeingTransformed}];
  @if transformType == 'real'
  ${fftwPrefix}_r2r_kind _r2r_kinds[${dimensionsBeingTransformed}];
  @end if
  
  int _transform_sizes_index = 0;
  
  @#
  @for dimID, dimRep in enumerate(transformPair[0])
  _transform_sizes[_transform_sizes_index++] = ${dimRep.globalLattice};
  @end for

  @if transformType == 'complex'
    @set $guruPlanFunction = self.createGuruMPIDFTPlanInDirection
  @else
    @set $guruPlanFunction = self.createGuruMPIR2RPlanInDirection
  @end if
  @#
  ${guruPlanFunction(
      transformDict, 'forward', dataOut,
      '_unswapped_block_size', '_swapped_block_size', 'FFTW_MPI_TRANSPOSED_OUT'
    ), autoIndent=True}@slurp
  ${guruPlanFunction(
      transformDict, 'backward', dataOut,
      '_swapped_block_size', '_unswapped_block_size', 'FFTW_MPI_TRANSPOSED_IN'
    ), autoIndent=True}@slurp
  
  // Save wisdom
  #if CFG_OSAPI == CFG_OSAPI_POSIX
  ${saveWisdom, autoIndent=True}@slurp
  #endif // POSIX
  
  _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
}

if (_forward) {
  ${fftwPrefix}_execute_r2r(
    _fftw_forward_plan,
    reinterpret_cast<real*>(_data_in),
    reinterpret_cast<real*>(${dataOut})
  );
} else {
  ${fftwPrefix}_execute_r2r(
    _fftw_backward_plan,
    reinterpret_cast<real*>(_data_in),
    reinterpret_cast<real*>(${dataOut})
  );
}
  @#
@end def

@def createGuruMPIDFTPlanInDirection($transformDict, $direction, $dataOut, $inBlockSize, $outBlockSize, $transposedState)
  @#
_fftw_${direction}_plan = ${fftwPrefix}_mpi_plan_many_dft(
  _transform_sizes_index, _transform_sizes, _postfix_lattice,
  ${inBlockSize}, ${outBlockSize},
  reinterpret_cast<${fftwPrefix}_complex*>(_data_in),
  reinterpret_cast<${fftwPrefix}_complex*>(${dataOut}),
  MPI_COMM_WORLD, FFTW_${direction.upper()}, ${planType} | ${transposedState}
);
if (!_fftw_${direction}_plan)
  _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create ${direction} mpi dft plan.\n", __FILE__, __LINE__);

  @#
@end def

@def createGuruMPIR2RPlanInDirection($transformDict, $direction, $dataOut, $inBlockSize, $outBlockSize, $transposedState)
  @#
  @for idx, dimRep in enumerate(transformDict['transformPair'][0])
_r2r_kinds[${idx}] = ${r2rKindForDimensionAndDirection(dimRep.name, direction)};
  @end for

_fftw_${direction}_plan = ${fftwPrefix}_mpi_plan_many_r2r(
  _transform_sizes_index, _transform_sizes, _postfix_lattice,
  ${inBlockSize}, ${outBlockSize},
  reinterpret_cast<real*>(_data_in),
  reinterpret_cast<real*>(${dataOut}),
  MPI_COMM_WORLD, _r2r_kinds, ${planType} | ${transposedState}
);

if (!_fftw_${direction}_plan)
  _LOG(_ERROR_LOG_LEVEL, "(%s: %i) Unable to create ${direction} mpi r2r plan.\n", __FILE__, __LINE__);
  @#
@end def


@def loadWisdom
  @#
  @super
  @#
${fftwPrefix}_mpi_broadcast_wisdom(MPI_COMM_WORLD);
  @#
@end def

@def saveWisdom
  @#
${fftwPrefix}_mpi_gather_wisdom(MPI_COMM_WORLD);
  @#
  @super
  @#
@end def
