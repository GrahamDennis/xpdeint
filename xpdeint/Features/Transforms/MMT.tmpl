@*
MMT.tmpl

Created by Graham Dennis on 2008-12-12.
Copyright (c) 2008 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Features.Transforms._MMT

@from xpdeint.Geometry.NonUniformDimensionRepresentation import NonUniformDimensionRepresentation

@def description: MMT
@attr $uselib = ['cblas']

@from xpdeint.CallOnceGuards import callOnceGuard

@def includes
  @#
  @super
  @#
#if   defined(CBLAS_MKL)
  #include <mkl.h>
#elif defined(CBLAS_VECLIB)
  #include <vecLib/cblas.h>
#elif defined(CBLAS_ATLAS)
  #include <cblas.h>
#elif defined(CBLAS_GSL)
  #include <gsl/gsl_cblas.h>
#endif
  @#
@end def

@def besselGlobalsForDim($dimName, $basisDict)
  @#
  @set $besselOrder = basisDict['order'] + basisDict['orderOffset']
  @set $lattice = basisDict['lattice']
const real _normbesseljzeros_${dimName}[] = {${wrapArray($normalisedBesselJZeros(besselOrder, lattice))}};
const real _besseljnorm_${dimName} = ${besselJZeros(besselOrder, lattice+1)[-1]};
  @#
@end def

@def hermiteGaussGlobalsForDim($dimName, $basisDict)
  @#
  @set $lattice = basisDict['lattice']
const real _hermite_zeros_${dimName}[] = {${wrapArray($hermiteZeros(lattice))}};
const real _hermite_gauss_weights_${dimName}[] = {${wrapArray($hermiteGaussWeights(lattice))}};
  @#
@end def

@def mainBegin($dict)
  @#

  @if $simulationBuildVariant == 'mpi'
#if defined(CBLAS_VECLIB)
// We are using MPI. If we let vecLib spawn threads then overall performance will suffer
  setenv("VECLIB_MAXIMUM_THREADS", "1", 1);
#endif
  @end if
  @#
  @for dimName, basisDict in $basisMap.items()
    @for field in [field for field in $fields if field.hasDimensionName(dimName)]
      @if field == $geometry
        @continue
      @end if
      @for (fieldDimRep, geometryDimRep) in zip(field.dimensionWithName(dimName).representations, $geometry.dimensionWithName(dimName).representations)
        @if not fieldDimRep or not isinstance(fieldDimRep, NonUniformDimensionRepresentation)
          @continue
        @end if
        @assert (geometryDimRep.lattice % fieldDimRep.lattice) == 0
        @if geometryDimRep.lattice == fieldDimRep.lattice
memcpy(${fieldDimRep.arrayName}, ${geometryDimRep.arrayName}, sizeof(real)*${geometryDimRep.globalLattice});
memcpy(${fieldDimRep.stepSizeArrayName}, ${geometryDimRep.stepSizeArrayName}, sizeof(real) * ${geometryDimRep.globalLattice});
        @else
for (long _i0=0; _i0 < $fieldDimRep.globalLattice; _i0++) {
  ${fieldDimRep.arrayName}[_i0] = ${geometryDimRep.arrayName}[_i0 * ($geometryDimRep.globalLattice / $fieldDimRep.globalLattice)];
  ${fieldDimRep.stepSizeArrayName}[_i0] = ${geometryDimRep.stepSizeArrayName}[_i0 * ($geometryDimRep.globalLattice / $fieldDimRep.globalLattice)];
}
        @end if
      @end for
    @end for

  @end for
@end def

