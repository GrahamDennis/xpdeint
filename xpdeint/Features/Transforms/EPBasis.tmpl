@*
EPBasis.tmpl

Base class for a Basis where each basis function has definite parity
and the parity alternates between successive basis functions.
Bases inheriting from this class will use the faster Parity Matrix Multiplication Transform (PMMT).

Created by Graham Dennis on 2008-12-27.
Copyright (c) 2008 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Features.Transforms.Basis

@def globalsForDim($dim)
  @#
  @set $forwardDimRep = dim.inSpace(0)
  @set $backwardDimRep = dim.inSpace(-1)
real *_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name}_even;
real *_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name}_odd;
real *_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name}_even;
real *_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name}_odd;
  @#
@end def

@def transformFunctionStart($forwardDimRep, $backwardDimRep)
static real *_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name}_even = NULL;
static real *_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name}_odd  = NULL;
static real *_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name}_even = NULL;
static real *_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name}_odd  = NULL;
@end def


@def transformMatricesForDimReps($forwardDimRep, $backwardDimRep)
long _even_${forwardDimRep.name} = (${forwardDimRep.globalLattice} + 1)/2;
long _odd_${forwardDimRep.name} = ${forwardDimRep.globalLattice}/2;
long _even_${backwardDimRep.name} = (${backwardDimRep.globalLattice} + 1)/2;
long _odd_${backwardDimRep.name} = ${backwardDimRep.globalLattice}/2;
_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name}_even = (real *)xmds_malloc(sizeof(real) * _even_${forwardDimRep.name} * _even_${backwardDimRep.name});
_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name}_odd  = (real *)xmds_malloc(sizeof(real) * _odd_${forwardDimRep.name} * _odd_${backwardDimRep.name});
_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name}_even = (real *)xmds_malloc(sizeof(real) * _even_${backwardDimRep.name} * _even_${forwardDimRep.name});
_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name}_odd  = (real *)xmds_malloc(sizeof(real) * _odd_${backwardDimRep.name} * _odd_${forwardDimRep.name});

for (long _i0 = 0; _i0 < _even_${forwardDimRep.name}; _i0++) {
  long __i0 = ${forwardDimRep.globalLattice} - 1 - _i0;
  ${transformMatricesForwardDimConstantsAtIndex(forwardDimRep, backwardDimRep, '__i0'), autoIndent=True}@slurp
  for (long _i1 = 0; _i1 < ${backwardDimRep.globalLattice}; _i1++) {
    ${transformMatricesForDimRepsAtIndices(forwardDimRep, backwardDimRep, '_i0', '_i1'), autoIndent=True}@slurp
  }
}
@end def

@def transformMatricesForDimRepsAtIndices($forwardDimRep, $backwardDimRep, $forwardIndex, $backwardIndex)
  @#
if (${backwardIndex} & 1) {
  // ${backwardIndex} is odd
  if (${forwardIndex} < _odd_${forwardDimRep.name}) {
    ${transformMatricesForDimRepsAtIndicesOfKind(forwardDimRep, backwardDimRep, forwardIndex, backwardIndex, 'odd'), autoIndent=True}@slurp
  }
} else {
  // ${backwardIndex} is even
  ${transformMatricesForDimRepsAtIndicesOfKind(forwardDimRep, backwardDimRep, forwardIndex, backwardIndex, 'even'), autoIndent=True}@slurp
}
  @#
@end def

@def transformMatricesForDimRepsAtIndicesOfKind($forwardDimRep, $backwardDimRep, $forwardIndex, $backwardIndex, $kind)
  @#
  @set $logicalForwardIndex = '_' + forwardIndex
  @set $logicalBackwardIndex = backwardIndex
  @set $actualBackwardIndex = '_' + backwardIndex
  @if kind == 'even'
    @set $actualForwardIndex = forwardIndex
  @else
    @set $actualForwardIndex = c'(_odd_${forwardDimRep.name} -1 - $forwardIndex)'
  @end if
long ${actualBackwardIndex} = ${backwardIndex}/2;
_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name}_${kind}[${actualBackwardIndex} * _${kind}_${forwardDimRep.name} + ${actualForwardIndex}] = \
  ${forwardMatrixForDimAtIndices(forwardDimRep, backwardDimRep, logicalForwardIndex, logicalBackwardIndex)};
_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name}_${kind}[${actualForwardIndex} * _${kind}_${backwardDimRep.name} + ${actualBackwardIndex}] = \
  ${backwardMatrixForDimAtIndices(forwardDimRep, backwardDimRep, logicalForwardIndex, logicalBackwardIndex)};
  @#
@end def

@def performTransform($sourceDimRep, $destDimRep, $dir = None)
  @#
  @if dir == 'forward'
${performForwardTransform(sourceDimRep, destDimRep)}@slurp
  @else
${performBackwardTransform(sourceDimRep, destDimRep)}@slurp
  @end if
@end def

@def performForwardTransform($sourceDimRep, $destDimRep)
  @#
// Loop to create symmetric and antisymmetric components.
real _temp;
long outerOffset = _i0 * innerLoopSize * ${sourceDimRep.globalLattice};
for (long _i1 = 0; _i1 < ${sourceDimRep.globalLattice}/2; _i1++) {
  real* __restrict__ _low = &source_data[outerOffset + _i1 * innerLoopSize];
  real* __restrict__ _high = &source_data[outerOffset + (${sourceDimRep.globalLattice} - 1 - _i1) * innerLoopSize];
  for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
    _temp = _low[_i2];
    _low[_i2] += _high[_i2];  // _low stores the symmetric component
    _high[_i2] -= _temp; // _high stores the antisymmetric component
  }
}
// Symmetric component of the transform
cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
            (${destDimRep.globalLattice}+1)/2,
            /* nelem */ innerLoopSize,
            (${sourceDimRep.globalLattice}+1)/2,
            /* alpha */ 1.0,
            /* A */ _mmt_matrix_${sourceDimRep.name}_${destDimRep.name}_even, (${sourceDimRep.globalLattice}+1)/2,
            /* B */ source_data + _i0 * ${sourceDimRep.globalLattice} * innerLoopSize,
                    innerLoopSize,
            /* beta */ 0.0,
            /* C */ dest_data + _i0 * ${destDimRep.globalLattice} * innerLoopSize,
            2 * innerLoopSize);
// Antisymmetric component of the transform
cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
            ${destDimRep.globalLattice}/2,
            /* nelem */ innerLoopSize,
            ${sourceDimRep.globalLattice}/2,
            /* alpha */ 1.0,
            /* A */ _mmt_matrix_${sourceDimRep.name}_${destDimRep.name}_odd, ${sourceDimRep.globalLattice}/2,
            /* B */ source_data + (_i0 * ${sourceDimRep.globalLattice} + (${sourceDimRep.globalLattice}+1)/2) * innerLoopSize,
                    innerLoopSize,
            /* beta */ 0.0,
            /* C */ dest_data + (_i0 * ${destDimRep.globalLattice} + 1) * innerLoopSize,
            2 * innerLoopSize);
  @#
@end def

@def performBackwardTransform($sourceDimRep, $destDimRep)
  @#
// Symmetric component of the transform
cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
            (${destDimRep.globalLattice}+1)/2,
            /* nelem */ innerLoopSize,
            (${sourceDimRep.globalLattice}+1)/2,
            /* alpha */ 1.0,
            /* A */ _mmt_matrix_${sourceDimRep.name}_${destDimRep.name}_even, (${sourceDimRep.globalLattice}+1)/2,
            /* B */ source_data + _i0 * ${sourceDimRep.globalLattice} * innerLoopSize,
                    2 * innerLoopSize,
            /* beta */ 0.0,
            /* C */ dest_data + _i0 * ${destDimRep.globalLattice} * innerLoopSize,
            innerLoopSize);
// Antisymmetric component of the transform
cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
            ${destDimRep.globalLattice}/2,
            /* nelem */ innerLoopSize,
            ${sourceDimRep.globalLattice}/2,
            /* alpha */ 1.0,
            /* A */ _mmt_matrix_${sourceDimRep.name}_${destDimRep.name}_odd, ${sourceDimRep.globalLattice}/2,
            /* B */ source_data + (_i0 * ${sourceDimRep.globalLattice} + 1) * innerLoopSize,
                    2 * innerLoopSize,
            /* beta */ 0.0,
            /* C */ dest_data + (_i0 * ${destDimRep.globalLattice} + (${destDimRep.globalLattice}+1)/2) * innerLoopSize,
            innerLoopSize);
// Loop to unravel symmetric and antisymmetric components.
real _temp;
long outerOffset = _i0 * innerLoopSize * ${destDimRep.globalLattice};
for (long _i1 = 0; _i1 < ${destDimRep.globalLattice}/2; _i1++) {
  // _low stored the symmetric component
  real* __restrict__ _low = &dest_data[outerOffset + _i1 * innerLoopSize];
  // _high stored the antisymmetric component
  real* __restrict__ _high = &dest_data[outerOffset + (${destDimRep.globalLattice} - 1 - _i1) * innerLoopSize];
  for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
    _temp = _low[_i2];
    // _low is the negative domain
    _low[_i2] -= _high[_i2];
    // _high is the positive domain
    _high[_i2] += _temp;
  }
}
  @#
@end def

@def destroyTransformMatricesForDim($dim)
  @#
  @set $forwardDimRep = dim.inSpace(0)
  @set $backwardDimRep = dim.inSpace(-1)
xmds_free(_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name}_even);
xmds_free(_mmt_matrix_${forwardDimRep.name}_${backwardDimRep.name}_odd);
xmds_free(_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name}_even);
xmds_free(_mmt_matrix_${backwardDimRep.name}_${forwardDimRep.name}_odd);
  @#
@end def