@*
Arguments.tmpl

Created by Mattias Johnsson on 2008-02-21.
Copyright (c) 2008 Mattias Johnsson. All rights reserved.
*@
@extends xpdeint.Features._Feature

@def description: Command line argument processing
@attr featureName = 'Arguments'

@def includes
  @#
  @super
  @#
#include <getopt.h>
  @#
@end def

@def globals
  @#
  @super
  @#
  @for $argument in $argumentList
    @if $argument.type == "string"
$argument.type $argument.name = "$argument.defaultValue";
    @else
$argument.type $argument.name = $argument.defaultValue; 
    @end if
  @end for
  @#
@end def

@def functionPrototypes
  @#
  @super
  @#
void _print_usage();
  @#
@end def

@def functionImplementations
  @#
  @super
  @#
void _print_usage()
{
  // This function does not return.
  _LOG(_ERROR_LOG_LEVEL, "Usage: $simulationName@slurp
@for $argument in $argumentList
 -$argument.shortName < $argument.type >@slurp
@end for
\n\n"
                         "Details:\n"
                         "Option\t\tType\t\tDefault value\n"
@for $argument in $argumentList
                         "-$argument.shortName, --$argument.name\t$argument.type \t\t$argument.defaultValue\n"
@end for
                         );
  // Simulation will have exited due to _LOG
}
  @#
@end def


@def mainBegin($dict)
// *********** Parse the command line for arguments, and set  *********
// *********** the appropriate global variables               *********
int resp;
while (1) {
  static struct option long_options[] = 
    {
      {"help", no_argument, 0, 'h'},
  @for $argument in $argumentList
      {"$argument.name", required_argument, 0, '$argument.shortName'},
  @end for
    };
  
  int option_index = 0;
  
  resp = getopt_long(argc, argv, "h@slurp
  @for $argument in $argumentList
$argument.shortName:@slurp
  @end for
", long_options, &option_index);
  
  if (resp == -1)
    break;
  
  switch (resp) {
    case 'h':
      _print_usage(); // This causes the simulation to exit
  @for $argument in $argumentList
      
    case '$argument.shortName':
    @if $argument.type == 'string'
      $argument.name = string(optarg);
    @elif $argument.type in ('int', 'long'):
      $argument.name = strtol(optarg, NULL, 10);
    @elif $argument.type in 'double'
      $argument.name = strtod(optarg, NULL);
    @end if
      break;
  @end for
      
    default:
      _LOG(_ERROR_LOG_LEVEL, "Internal error in processing arguments.\n");
  }
}

if (optind < argc)
  _print_usage(); // This causes the simulation to exit.

  @if $postArgumentsCodeEntity.value
// ******** Argument post-processing code *******
${insertUserCodeFromEntity($postArgumentsCodeEntity)}@slurp
// **********************************************

  @end if
  @#
@end def

@def xsilOutputInfo($dict)
  @#
  @set $fp = dict['fp']
  @set $formatSpecifierMap = {'string': ('s', '.c_str()'),
                              'int':    ('i', ''),
                              'long':   ('li', ''),
                              'double': ('e', '')}
  @#
fprintf($fp, "\nVariables that can be specified on the command line:\n");
  @for $argument in $argumentList

    @set formatSpecifier, argumentSuffix = formatSpecifierMap[$argument.type]
fprintf($fp, "  Command line argument ${argument.name} = %${formatSpecifier}\n", ${argument.name}${argumentSuffix});
  @end for
  @#
@end def
