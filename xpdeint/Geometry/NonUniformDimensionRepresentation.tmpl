@*
NonUniformDimensionRepresentation.tmpl

Created by Graham Dennis on 2008-07-30.
Copyright (c) 2008 __MyCompanyName__. All rights reserved.
*@
@extends xpdeint.Geometry._NonUniformDimensionRepresentation

@def defines
  @#
  @if $lattice
    @super
#define ${minimum}     (${arrayName}[0])
#define ${maximum}     (${arrayName}[${globalLattice}-1])
    @if not $stepSizeArray
#define ${stepSize}        (${arrayName}[${loopIndex}+1]-${arrayName}[${loopIndex}])
    @end if
  @end if
  @#
@end def

@def globals
  @#
  @super
  @#
  @if $lattice
    @# We allocate an extra point so that evaluating ${stepSize} at the end of the grid
    @# doesn't cause a SEGFAULT
unsigned long ${index} = 0;
${type}* ${arrayName} = (${type}*) xmds_malloc(sizeof(${type}) * (${globalLattice}+1));
    @if $stepSizeArray
${type}* ${stepSizeArrayName} = (${type}*) xmds_malloc(sizeof(${type}) * (${globalLattice}));
    @end if
  @end if
  @#
  @if $hasLocalOffset
ptrdiff_t $localLattice = 0;
ptrdiff_t $localOffset = 0;
  @end if
  @#
@end def

@def openLoopAscending
  @#
  @# Non-uniform dimensions do not currently support being distributed
  @assert not $hasLocalOffset
#define ${name} ${arrayName}[${loopIndex}]
  @if $stepSizeArray
#define d${name} ${stepSizeArrayName}[${loopIndex}]
  @end if

for (long ${loopIndex} = 0; ${loopIndex} < ${localLattice}; ${loopIndex}++) {
@end def

@def closeLoopAscending
  @#
}
#undef ${name}
  @if $stepSizeArray
#undef d${name}
  @end if
  @#
@end def

@def localIndexFromIndexForDimensionRep($dimRep)
  @#
(${dimRep.loopIndex} + ${dimRep.localOffset}) * (${globalLattice}/${dimRep.globalLattice}) - ${localOffset}@slurp
  @#
@end def

@def strictlyAscendingGlobalIndex
  @#
${loopIndex} + ${localOffset}@slurp
  @#
@end def
