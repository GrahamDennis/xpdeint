Welcome to xpdeint, the development testing project for xmds.

This code is written in python and generates C++ code that is very similar to the
code generated by xmds. It relies on Cheetah Templates (www.cheetahtemplate.org, you
need at least version 2.0.1) to remove the fprintf nightmare in xmds.

First, let's dive into the build instructions before we talk about features.

Build instructions:
0. Obtain xpdeint. In a directory where you want to check out the repository, run:
   svn checkout https://xmds.svn.sourceforge.net/svnroot/xmds/trunk/xpdeint .
   (Only do this if you haven't done this already).
1. As xpdeint generates C++ code, you will need a C++ compiler. One common free compiler is gcc.
   xpdeint can also use Intel's C++ compiler if you have it. Intel's compiler typically generates
   faster code than gcc, but it isn't free.
   Mac OS X: Xcode and other development comes free on the Mac OS X install discs. Install the 
   Development package or Xcode (or whatever it is called) in the Optional Installs folder on the
   installation disk.
   Linux: Install 'gcc' or 'g++' using your favourite package manager.

2. Install python 2.4 or greater. (2.5 recommended)
   Mac OS X: The easiest way to do this is by downloading a .dmg from http://pythonmac.org/packages/.
   If you have Leopard (10.5) or later, then python 2.5 comes pre-installed.
   
   Linux: Install this using your favourite package manager.
   Windows: One way to install Python and related packages is via the Enthought Python Distribution.
            http://www.enthought.com/products/epd.php
   
3. Install setuptools.
   Linux: Use your favourite package manager (if you can).
   Windows: If you used the Enthought Python Distribution, this is already installed.
   
   Mac OS X: Leopard (10.5) has setuptools pre-installed.
   
   If you have root (sudo) access, the easy way to install this is by executing
   ez_setup.py from the repository. Simply type "sudo python ez_setup.py"
   
   If you want to install into your home directory without root access, this is more complex:
   a) First create the path ~/lib/python2.5/site-packages (assuming you installed python version 2.5) and ~/bin
      Add "export PYTHONPATH=~/lib/python2.5/site-packages:$PYTHONPATH" and "export PATH=~/bin:$PATH" (if necessary)
      to your .bashrc file (and run ". ~/.bashrc")

   b) If necessary install setuptools, by executing ez_setup.py from the repository.
      "python ez_setup.py --prefix=~"

4. Install Cheetah version 2.0.1 or later, Pygments, and (optionally) lxml. 
   If you have root access, this is as easy as:
   "sudo easy_install Cheetah" or "sudo easy_install Pygments" or "sudo easy_install lxml"
   Make sure you have 'libxml2' and 'libxslt' installed (and the development packages if
   you're using a package manager) if you want to install lxml.
   
   If you don't have root access or want to install into your home directory, use:
   "easy_install --prefix=~ Cheetah" (etc.)
   
   Note that lxml is not required for xpdeint to run. If it is installed, it is used to validate
   the xmds script passed to xpdeint to check that there isn't any invalid syntax or typos that
   xpdeint wouldn't have otherwise noticed. Also note that installing lxml is a bit tricky on OS X
   because Apple continues to ship old versions of libxml2 with the system.
   
   Pygments and Cheetah are required installs for xpdeint.

5. Cheetah templates (*.tmpl) are compiled into python, to do this, run 'make' in the
   xpdeint/ directory.

6. Install xpdeint into your python path by running (in the xpdeint/ directory):
   sudo ./setup.py develop
   
   If you want to install it into your home directory, type "./setup.py develop --prefix=~"

7. a) Test xpdeint by running (in the xpdeint/xpdeint/examples/ directory):
      xpdeint kubo.xmds
7. b) If you have 'numpy' installed, type './run_tests.py' in the xpdeint/ directory
      to run all the tests

8. Run the generated program, which will produce XSIL output exactly as XMDS-1

   Note that xpdeint currently requires xmds-1 to be installed for libxmds when loading XSIL files.
   It also currently uses the xsil2graphics program bundled with xmds-1.

9. Next time you want to update, just type 'make update' in the xpdeint/ directory.

10. Sign up to the xmds-commit list at https://lists.sourceforge.net/lists/listinfo/xmds-commit.
    This is a reasonably important step as xpdeint is still very much a moving target and things
    can still change or bugs can be found. Signing up to this list means you can keep track of these
    things. If you're not interested in the up-to-the-moment updates (most people won't be), sign up
    for the 'daily digest' instead.

11. To build the user documentation, you first need to install sphinx, either via your package manager or:
    sudo easy_install sphinx

    Then, to build the documentation, in the xpdeint/userdoc/ directory run:
    make html

    If this results in an error, you may need run
    sudo ./setup.py develop

    The generated html documentation can now be found at xpdeint/userdoc/build/html/index.html


Optional installs:
* A Matrix library like ATLAS, or Intel's MKL. (Mac OS X comes with a matrix library)
* GNU Scientific library (GSL).
* HDF5, A library for the Heirachical Data Format (http://www.hdfgroup.org/HDF5/)
  and h5py (sudo easy_install h5py). This is needed for writing and reading the hdf5 file format.
  Don't worry so much about h5py, it is only needed to run the testcases that use HDF5.
* numpy (sudo easy_install numpy). (Mac OS X Leopard comes with numpy)
* fftw-3.3alpha. Needed for fourier transforms. The alpha version is required for MPI support.
* OpenMPI. Needed to enable xpdeint to generate scripts that can be run across multiple machines. (Mac OS X Leopard comes with OpenMPI)
* mpmath. Library for arbitrary precision floating point math. Install from package manager or "sudo easy_install mpmath"

This should mostly work.

So far the feature list includes:
* RK4, RK9, ARK45, ARK89 integrators
* IP/EX operators are separate from the integration algorithm, so you  
  can have both IP and EX operators in a single integrate block. Also,
  EX operators can act on arbitrary code, not just vector components.
* The ability to have more than one noise kind in a simulation.
* Adaptive integrators that are stochastic-safe for Poissonian noises
  as well as gaussian noises.  Not that the RK algorithms are technically not safe, however.
  You may still obtain good results if the deterministic evolution limits the timestep.
* Cross propagation in the increasing direction of a given dimension
  or in the decreasing dimension. And you can have more than one
  cross-propagator in a given integrator (going in different directions
  or dimensions).
* Fields of different dimensions.
* Integrate more than one vector (in more than one field), so you can  
  now simultaneously integrate a PDE and a coupled ODE
* OpenMP support
* From a developer point of view, many things have been abstracted, so  
  adding a new Fourier transform library shouldn't be difficult.
* Non-Fourier transformations have been included.  These include the Bessel basis, 
  Spherical Bessel basis and the Hermitee-Gauss basis.
* Output moment groups use less memory when there isn't a  
  post_processing element
* Generated source is indented correctly
* An xmds-1 like script file format.
* xmds-1 like generated source. In many places existing internal hacks  
  could work in xpdeint.

Currently the parser2.py doesn't read any preferences, it just loads an xmds script passed
as an argument writes the generated source to file, and compiles the file.

Here are a couple of potential projects that would be good introductions
into the code base:

1. Write the frontend (in python). This is a good project for someone
   familiar with python.

   My idea is that this relies entirely on a configuration file
   (~/.xmds/xmds2_config or something) instead of hard-coded things generated
   from compile time. For example, I think it is silly that you need to
   recompile xmds to be able to generate scripts that can use MPI if you
   didn't initially compile xmds for MPI despite xmds itself not using
   MPI. So the frontend would do all the usual things that the xmds-1
   frontend does like reading command line arguments, outputting the generated
   file and compiling it. So the config file would say whether or not fftw2 or
   fftw3 was available.
   An initial config file could be generated by autoconf when libxmds
   is compiled.

2. Rewrite xsil2graphics using Python and Cheetah for templates.
   This is a good intro project into using Cheetah.

3. Anything in the TODO.


Cheetah templates are basically a nice way of writing code whose primary purpose
is to generate a string. These templates are compiled into python classes which
can inherit from one another or from other python classes. These templates are
denoted by the .tmpl suffix, and generate .py files of the same name when compiled
by Cheetah.


Finally, I'll describe the general purpose of the different files:

_*.py files: These are the python superclasses for Cheetah Templates  
  (Cheetah Templates generate python source files) where any pure-python  
  code for a Cheetah template goes. This is also useful when an __init__  
  method needs to be written as Cheetah doesn't provide a facility to  
  modify its generated __init__ method.
*.tmpl files: The actual Cheetah Templates. The Cheetah Templates  
  generate all of the code for the generated source files, the code, I  
  think is mostly a more natural way to write generated code as opposed  
  to the fprintf nightmare.
*Element.* files: The base-level script elements, fairly self- 
  explanatory.
*Integrator.* files: The various integration algorithms. These are  
  loosely coupled to the IP/EX/etc operators
*Operator.* files: These are the various 'operators' inside  
  integration blocks. These include IP/EX operators, moment calculations  
  and the actual derivative (delta-a) calculations

*Feature.* files: These are the 'additional' things that add in to the  
  simulation and modify it. They are inserted into the generated source  
  file through the other templates calling  
  $insertCodeForFeatures( insertionPointName, featureList) where  
  featureList is an ordered list of the features that may want to insert  
  code at this point. This way we can more clearly separate error  
  checking and other things from the basic simulation script.  
  BenchmarkFeature is a good example of a basic feature.

*parser* files: The XML parser and its tools

CallOnceGuards.py: Used for all Python CallOnceGuards

*Filter.py: Cheetah Filters. These 'filter' the generated source as it  
  goes. IndentFilter indents the code property (if you provide it the  
  right arguments), PrintfFilter properly escapes strings that need to  
  go in a printf statement.

*.xmds: xmds-2 script files used for testing. The syntax is fairly  
  obvious. Though the format is up for debate.


I've tried to document my code as I went, and where I  
didn't, make variable and method names sufficiently verbose to make  
things clear. About the only real piece of black magic is  
ScriptElement.tmpl which writes all of the looping code and handles  
whether or not dimensions are being looped over, integrated, etc.
Note that not all documentation is in the form of docstrings. This needs
to be fixed.

The only other thing I would mention is that the Cheetah documentation  
is incomplete, and is from version 1.0. There have been a few features  
added through to 2.0 that I have been using that are only described in  
the CHANGES document available from the Cheetah website. Specifically,  
I've been using 'Cheetah strings' (c'stuff' syntax, like Python's  
r'stuff' raw-string syntax), CallOnceGuards in templates, and the 'capture'
directive.
