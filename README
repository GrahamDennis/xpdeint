Welcome to xpdeint, the development testing project for xmds.

This code is written in python and generates C++ code that is very similar to the
code generated by xmds. It relies on Cheetah Templates (www.cheetahtemplates.org, you
need at least version 2.0.1) to remove the fprintf nightmare in xmds.

First, let's dive into the build instructions before we talk about features.

Build instructions:
1. Install python 2.5 or greater.
   Mac OS X: The easiest way to do this and later steps is to install MacPorts
   (www.macports.org). Once MacPorts is installed, simply type:
   sudo port install python25 py25-setuptools
   to install python 2.5 and the setuptools package.
   If you have Leopard (10.5) or later, then python 2.5 comes pre-installed.

   Linux: Install this using your favourite package manager.

2. Install Cheetah version 2.0.1 or later. If you have the setuptools python
   package installed, then you can simply type 'easy_install Cheetah'.

3. Cheetah templates (*.tmpl) are compiled into python, to do this, execute the
   following command (in the source/ directory):
   cheetah compile *.tmpl
   
4. Test xpdeint by running (in the source/ directory):
   ./parser2.py > output_file.cc

5. Hand-compile the generated source file, like:
   g++ -o output_file output_file.cc -lxmds -lfftw3

   Note that xpdeint currently requires xmds-1 to be installed for things  
   like libxmds and xmds_complex.h

This should mostly work. Note that to change the xmds script being used to generate
the simulation source, you will need to modify the parser2.py file.

So far the feature list includes:
* RK4, RK9, and ARK45 integrators
* IP/EX operators are separate from the integration algorithm, so you  
  can have both IP and EX operators in a single integrate block
* Fields of different dimensions
* Integrate more than one vector (in more than one field), so you can  
  now simultaneously integrate a PDE and a coupled ODE
* OpenMP support
* From a developer point of view, many things have been abstracted, so  
  adding a new fourier transform library shouldn't be difficult.
* Output moment groups use less memory when there isn't a  
  post_processing element
* Generated source is indented correctly
* An xmds-1 like script file format.
* xmds-1 like generated source. In many places existing internal hacks  
  could work in xpdeint.

Features missing:
* Stochastic support (I've mostly implemented this)
* Deterministic MPI support (nightmarish)
* A front-end (parse command line arguments to xmds, load the right  
  script, generate the right file, read a configuration file, work out  
  how to compile the script and compile it)
* An XMDS-1 parser. Currently it has a parser for the new xmds-2 xml  
  format (see example *.xmds files), but the parser has been written so  
  that you can simply write another subclass of the parser to handle  
  xmds-1 scripts so that xmds-2 could be backwards-compatible.
* Lots of small things: ASCII/Binary/XSIL import, a filter element  
  (though there is a filter operator which is similar to (but more  
  powerful than) the XMDS-1 moments operator), 'functions' for  
  integrate / filter blocks, argument handling, wisdom importing/ 
  exporting, parser for post_propagation element. The template code for  
  handling post_propagation has been written, just the parser hasn't.

Currently the parser2.py is a bare-bones wrapper around the XML parser  
which loads a hard-coded file (scriptName in parser2.py) and dumps the  
generated source file to stdout.


Here are a couple of potential projects that would be good introductions
into the code base:

1. Write the frontend (in python). This is a good project for someone
   familiar with python.

   My idea is that this relies entirely on a configuration file
   (~/.xmds/xmds2_config or something) instead of hard-coded things generated
   from compile time. For example, I think it is silly that you need to
   recompile xmds to be able to generate scripts that can use MPI if you
   didn't initially compile xmds for MPI despite xmds itself not using
   MPI. So the frontend would do all the usual things that the xmds-1
   frontend does like reading command line arguments, outputting the generated
   file and compiling it. So the config file would say whether or not fftw2 or
   fftw3 was available.
   An initial config file could be generated by autoconf when libxmds
   is compiled.

2. Rewrite xsil2graphics using Python and Cheetah for templates.
   This is a good intro project into using Cheetah.



Cheetah templates are basically a nice way of writing code whose primary purpose
is to generate a string. These templates are compiled into python classes which
can inherit from one another or from other python classes. These templates are
denoted by the .tmpl suffix, and generate .py files of the same name when compiled
by Cheetah.


Finally, I'll describe the general purpose of the different files:

_*.py files: These are the python superclasses for Cheetah Templates  
  (Cheetah Templates generate python source files) where any pure-python  
  code for a Cheetah template goes. This is also useful when an __init__  
  method needs to be written as Cheetah doesn't provide a facility to  
  modify its generated __init__ method.
*.tmpl files: The actual Cheetah Templates. The Cheetah Templates  
  generate all of the code for the generated source files, the code, I  
  think is mostly a more natural way to write generated code as opposed  
  to the fprintf nightmare.
*Element.* files: The base-level script elements, fairly self- 
  explanatory.
*Integrator.* files: The various integration algorithms. These are  
  loosely coupled to the IP/EX/etc operators
*Operator.* files: These are the various 'operators' inside  
  integration blocks. These include IP/EX operators, moment calculations  
  and the actual derivative (delta-a) calculations

*Feature.* files: These are the 'additional' things that add in to the  
  simulation and modify it. They are inserted into the generated source  
  file through the other templates calling  
  $insertCodeForFeatures( insertionPointName, featureList) where  
  featureList is an ordered list of the features that may want to insert  
  code at this point. This way we can more clearly separate error  
  checking and other things from the basic simulation script.  
  BenchmarkFeature is a good example of a basic feature.

*parser* files: The XML parser and its tools

Decorators: Used for all Python decorators

*Filter.py: Cheetah Filters. These 'filter' the generated source as it  
  goes. IndentFilter indents the code property (if you provide it the  
  right arguments), PrintfFilter properly escapes strings that need to  
  go in a printf statement.

*.xmds: xmds-2 script files used for testing. The syntax is fairly  
  obvious. Though the format is up for debate. I am currently debating  
  whether or not to remove the 'features' tag and move all children up  
  to the 'simulation' top level. The parser currently supports scripts  
  written either way, though I may completely remove the 'features' tag  
  in the future.


I've tried to document my code as I went, and where I  
didn't, make variable and method names sufficiently verbose to make  
things clear. About the only real piece of black magic is  
ScriptElement.tmpl which writes all of the looping code and handles  
whether or not dimensions are being looped over, integrated, etc.
Note that my documentation isn't in the form of docstrings. This needs
to be fixed.

The only other thing I would mention is that the Cheetah documentation  
is incomplete, and is from version 1.0. There have been a few features  
added through to 2.0 that I have been using that are only described in  
the CHANGES document available from the Cheetah website. Specifically,  
I've been using 'Cheetah strings' (c'stuff' syntax, like Python's  
r'stuff' raw-string syntax), and decorators in templates.
