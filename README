Welcome to xpdeint, the development testing project for xmds.

This code is written in python and generates C++ code that is very similar to the
code generated by xmds. It relies on Cheetah Templates (www.cheetahtemplate.org, you
need at least version 2.0.1) to remove the fprintf nightmare in xmds.

First, let's dive into the build instructions before we talk about features.

Build instructions:
1. Install python 2.5 or greater.
   Mac OS X: The easiest way to do this is by downloading a .dmg from http://pythonmac.org/packages/.
   If you have Leopard (10.5) or later, then python 2.5 comes pre-installed.

   Linux: Install this using your favourite package manager.

2. Install Cheetah version 2.0.1 or later. If you have the setuptools python
   package installed, then you can simply type 'easy_install Cheetah'.
   Mac OS X: Install setuptools by downloading http://peak.telecommunity.com/dist/ez_setup.py
       Execute via 'python ez_setup.py'.

3. Cheetah templates (*.tmpl) are compiled into python, to do this, run 'make' in the
   source/ directory.
   
4. Test xpdeint by running (in the source/ directory):
   ./parser2.py ../examples/kubo.xmds

5. Run the generated program, which will produce XSIL output exactly as XMDS-1

   Note that xpdeint currently requires xmds-1 to be installed for things  
   like libxmds and xmds_complex.h

This should mostly work.

So far the feature list includes:
* RK4, RK9, ARK45, ARK89 integrators
* IP/EX operators are separate from the integration algorithm, so you  
  can have both IP and EX operators in a single integrate block. Also,
  EX operators can act on arbitrary code, not just vector components.
* The ability to have more than one noise kind in a simulation.
* Adaptive integrators that are stochastic-safe for poissonian noises
  as well as gaussian noises.
* Cross propagation in the increasing direction of a given dimension
  or in the decreasing dimension. And you can have more than one
  cross-propagator in a given integrator (going in different directions
  or dimensions).
* Fields of different dimensions.
* Integrate more than one vector (in more than one field), so you can  
  now simultaneously integrate a PDE and a coupled ODE
* OpenMP support
* From a developer point of view, many things have been abstracted, so  
  adding a new fourier transform library shouldn't be difficult.
* Output moment groups use less memory when there isn't a  
  post_processing element
* Generated source is indented correctly
* An xmds-1 like script file format.
* xmds-1 like generated source. In many places existing internal hacks  
  could work in xpdeint.

Currently the parser2.py doesn't read any preferences, it just loads an xmds script passed
as an argument writes the generated source to file, and compiles the file.

Here are a couple of potential projects that would be good introductions
into the code base:

1. Write the frontend (in python). This is a good project for someone
   familiar with python.

   My idea is that this relies entirely on a configuration file
   (~/.xmds/xmds2_config or something) instead of hard-coded things generated
   from compile time. For example, I think it is silly that you need to
   recompile xmds to be able to generate scripts that can use MPI if you
   didn't initially compile xmds for MPI despite xmds itself not using
   MPI. So the frontend would do all the usual things that the xmds-1
   frontend does like reading command line arguments, outputting the generated
   file and compiling it. So the config file would say whether or not fftw2 or
   fftw3 was available.
   An initial config file could be generated by autoconf when libxmds
   is compiled.

2. Rewrite xsil2graphics using Python and Cheetah for templates.
   This is a good intro project into using Cheetah.

3. Anything in the TODO.


Cheetah templates are basically a nice way of writing code whose primary purpose
is to generate a string. These templates are compiled into python classes which
can inherit from one another or from other python classes. These templates are
denoted by the .tmpl suffix, and generate .py files of the same name when compiled
by Cheetah.


Finally, I'll describe the general purpose of the different files:

_*.py files: These are the python superclasses for Cheetah Templates  
  (Cheetah Templates generate python source files) where any pure-python  
  code for a Cheetah template goes. This is also useful when an __init__  
  method needs to be written as Cheetah doesn't provide a facility to  
  modify its generated __init__ method.
*.tmpl files: The actual Cheetah Templates. The Cheetah Templates  
  generate all of the code for the generated source files, the code, I  
  think is mostly a more natural way to write generated code as opposed  
  to the fprintf nightmare.
*Element.* files: The base-level script elements, fairly self- 
  explanatory.
*Integrator.* files: The various integration algorithms. These are  
  loosely coupled to the IP/EX/etc operators
*Operator.* files: These are the various 'operators' inside  
  integration blocks. These include IP/EX operators, moment calculations  
  and the actual derivative (delta-a) calculations

*Feature.* files: These are the 'additional' things that add in to the  
  simulation and modify it. They are inserted into the generated source  
  file through the other templates calling  
  $insertCodeForFeatures( insertionPointName, featureList) where  
  featureList is an ordered list of the features that may want to insert  
  code at this point. This way we can more clearly separate error  
  checking and other things from the basic simulation script.  
  BenchmarkFeature is a good example of a basic feature.

*parser* files: The XML parser and its tools

Decorators.py: Used for all Python decorators

*Filter.py: Cheetah Filters. These 'filter' the generated source as it  
  goes. IndentFilter indents the code property (if you provide it the  
  right arguments), PrintfFilter properly escapes strings that need to  
  go in a printf statement.

*.xmds: xmds-2 script files used for testing. The syntax is fairly  
  obvious. Though the format is up for debate.


I've tried to document my code as I went, and where I  
didn't, make variable and method names sufficiently verbose to make  
things clear. About the only real piece of black magic is  
ScriptElement.tmpl which writes all of the looping code and handles  
whether or not dimensions are being looped over, integrated, etc.
Note that not all documentation is in the form of docstrings. This needs
to be fixed.

The only other thing I would mention is that the Cheetah documentation  
is incomplete, and is from version 1.0. There have been a few features  
added through to 2.0 that I have been using that are only described in  
the CHANGES document available from the Cheetah website. Specifically,  
I've been using 'Cheetah strings' (c'stuff' syntax, like Python's  
r'stuff' raw-string syntax), decorators in templates, and the 'capture'
directive.
