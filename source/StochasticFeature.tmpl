#*
StochasticFeature.tmpl

Created by Graham Dennis on 2007-12-11.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*#
#extends _StochasticFeature

#from DeltaAOperator import DeltaAOperator

#def description: Stochastic
#attr $featureName = 'Stochastic'

#*
  Globals
*#
#def globals
  ##
  #set $noisesNeeded = filter(lambda x: x.noiseDistribution in ('gaussian', 'poissonian'), $noises)
// ********************************************************
// struct used to store step size and noise vector to ensure
// stochastic convergence
struct _dtdWstore {
  double _step;
  #for noise in noisesNeeded
    #for noiseVector in noise.noiseVectors.intervalues()
  double* _${noiseVector.id};
    #end for
  #end for
  _dtdWstore() {
    _step = 0;
  #for noise in noisesNeeded
    #for noiseVector in noise.noiseVectors.intervalues()
    _${noiseVector.id} = NULL;
    #end for
  #end for
  }
  ~_dtdWstore() {
  #for noise in noisesNeeded
    #for noiseVector in noise.noiseVectors.intervalues()
    xmds_free(_${noiseVector.id});
    #end for
  #end for
  }
};
  ##
#end def

#def vectorInitialisationBegin($dict)
  ##
  #set $caller = dict['caller']
  #set $noisesNeeded = $noises[:]
  #if hasattr(caller, 'noises')
    #set $noisesNeeded = caller.noises[:]
  #end if

double _var = 1.0#slurp
  #if len(caller.vector.field.dimensions)
 / $caller.vector.field.volumeElementInSpace($caller.vector.initialSpace)#slurp
  #end if
;

  #for noise in noisesNeeded
    #set $noiseVector = noise.noiseVectorForField(caller.vector.field)
_make_${noise.prefix}_noises(_var, 0.0, _${noiseVector.id}, _${caller.vector.field.name}_size * _${noiseVector.id}_ncomponents);
  #end for
  ##
#end def

#def noisesAndFieldsForIntegrator($integrator)
  ##
  #set $result = []
  #for field in integrator.integrationFields
    #set $deltaAOperatorList = filter(lambda x: x.field == field and isinstance(x, DeltaAOperator), integrator.operators)
    #assert len(deltaAOperatorList) == 1
    #set $deltaAOperator = deltaAOperatorList[0]
    ##
    #set $noisesNeeded = $noises[:]
    #if hasattr(deltaAOperator, 'noises')
      #set $noisesNeeded = deltaAOperator.noises[:]
    #end if
    #silent result.extend([(noise, field) for noise in noisesNeeded])
  #end for
  #return result
  ##
#end def

#def integrateFixedStepBegin($dict)
  ##
  #set $integrator = dict['caller']
  ##
  #for field in integrator.integrationFields
const double _${field.name}_dVdt = #slurp
  #if len($field.dimensions)
$field.volumeElementInSpace(0) * #slurp
  #end if
_noiseStep;
const double _${field.name}_var = 1.0/_${field.name}_dVdt;
  #end for
  ##
#end def

#def integrateAdaptiveStepBegin($dict)
  ##
  #set $integrator = dict['caller']
  ##
  #for field in integrator.integrationFields
const double _${field.name}_dVdt = #slurp
  #if len($field.dimensions)
$field.volumeElementInSpace(0) * #slurp
  #end if
_noiseStep;
const double _${field.name}_var = 1.0/_${field.name}_dVdt;
  #end for

list<_dtdWstore> _noise_list;
list<_dtdWstore>::iterator _active_node;
  ##
#end def

#def integrateAdaptiveStepEnd($dict)
  ##
  #set $integrator = dict['caller']
  ##
  #for (noise, field) in self.nosiesAndFieldsForIntegrator(integrator)
    #set $noiseVector = noise.noiseVectorForField(field)
_active_${noiseVector.id} = _${noiseVector.id};
  #end for
#end def

#def integrateFixedStepInnerLoopBegin(dict)
  ##
  #set $integrator = dict['caller']
  #set $featureOrdering = ['ErrorCheck']
  ##
  #for (noise, field) in self.noisesAndFieldsForIntegrator(integrator)
    #set $noiseVector = noise.noiseVectorForField(field)

_make_${noise.prefix}_noises(_${integrationField.name}_var, _${integrationField.name}_dVdt,#slurp
 _${noiseVector.id}, _${integrationField.name}_size * _${noiseVector.id}_ncomponents);
    ##
    #set $makeNoisesDict = {'noise': noise, 'noiseVector': noiseVector, 'field': field}
${insertCodeForFeatures('makeNoisesForFixedStep', featureOrdering, makeNoisesDict)}#slurp
  #end for
  ##
#end def

#def integrateAdaptiveStepInnerLoopBegin(dict)
  ##
  #set $integrator = dict['caller']
  ##
if (_noise_list.empty()) { 
  // Noise list empty so start afresh
  _noise_list.push_front(_dtdWstore()); 
  _active_node = _noise_list.begin(); 
  _active_node->_step = _step; 
  #for (noise, field) in $noisesAndFieldsForIntegrator(integrator)
   #set $noiseVector = noise.noiseVectorForField(field)

  _active_${noiseVector.id} = (double*) xmds_malloc(sizeof(double) * _${field.name}_size * _${noiseVector.id}_ncomponents);
  _make_${noise.prefix}_noises(_${field.name}_var/_step, _${field.name}_dVdt*_step,#slurp
 _active_${noiseVector.id}, _${field.name}_size * _${noiseVector.id}_ncomponents);
  _active_node->_${noiseVector.id} = _active_${noiseVector.id};
  #end for
} else if (_step*(1.0 + _epsilon) < _noise_list.begin()->_step) {
  // Create new smallest time step
  _noise_vector = new double[_main_size*_n_noises];
  _make_noises(_gen1, _var*(_noise_list.begin()->_step - _step)/(_step*_noise_list.begin()->_step), _noise_vector, _main_size*_n_noises);
  for (long _i0 = 0; _i0 < _main_size*_n_noises; _i0++) { 
    _noise_vector[_i0] += _noise_list.begin()->_noise_vector[_i0]; 
  } 
  _noise_list.push_front(_dtdWstore()); 
  _active_node = _noise_list.begin(); 
  _active_node->_step = _step; 
  _active_node->_noise_vector = _noise_vector; 
} else { 
  // Use time step already attempted 
  for (_active_node = _noise_list.begin(); (_active_node != _noise_list.end()) && (_active_node->_step <= _step*(1.0+_epsilon)); _active_node++)
    ;

  _active_node--;
  _step = _active_node->_step; 
  _noise_vector = _active_node->_noise_vector; 
  if (_break_next && fabs(t + _step - _t_break_next) > _step*_epsilon)
    _break_next = false;
} 



if (_noise_list.empty()) { 
   // Noise list empty so start afresh
   _noise_vector = new double[_main_size*_n_noises];
   _make_noises(_gen1, _var/_step, _noise_vector, _main_size*_n_noises);
   _noise_list.push_front(_dtdWstore()); 
   _active_node = _noise_list.begin(); 
   _active_node->_step = _step; 
   _active_node->_noise_vector = _noise_vector; 
} 
else { 
   if (_step*(1.0+_epsilon) < _noise_list.begin()->_step) { 
 _noise_vector = new double[_main_size*_n_noises];
     //Create new smallest time step 
       _make_noises(_gen1, _var*((_noise_list.begin()->_step)-_step)/(_step*_noise_list.begin()->_step), _noise_vector, _main_size*_n_noises);
       for (unsigned long _i0=0; _i0<_main_size*_n_noises; _i0+=1) { 
          _noise_vector[_i0] += _noise_list.begin()->_noise_vector[_i0]; 
       } 
    _noise_list.push_front(_dtdWstore()); 
    _active_node = _noise_list.begin(); 
    _active_node->_step = _step; 
    _active_node->_noise_vector = _noise_vector; 
 } 
 else { 
     //Use time step already attempted 
 for (_active_node = _noise_list.begin(); (_active_node != _noise_list.end()) && (_active_node->_step <= _step*(1.0+_epsilon)); _active_node++) ;

 _active_node--; 
   _step = _active_node->_step; 
   _noise_vector = _active_node->_noise_vector; 
   if (_break_next && fabs(t + _step - _t_break_next) > _step*_epsilon)
     _break_next = false;
 } 
} 
  
  
  
  
  #for (noise, field) in $noisesAndFieldsForIntegrator(integrator)
    #set $noiseVector = noise.noiseVectorForField(field)
_make_${noise.prefix}_noises(_${field.name}_var / _step, _${field.name}_dVdt * _step,#slurp
 _${noiseVector.id}, _${field.name}_size * _${noiseVector.id}_ncomponents);
  #end for
  ##
#end def

