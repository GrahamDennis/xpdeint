#*
PoissonianPOSIXNoise.tmpl

Created by Graham Dennis on 2007-12-14.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*#
#extends POSIXNoise
#from Decorators import callOncePerClassGuard

#def description: Poissonian noise
#attr $noiseDistribution = 'poissonian'

#*
  Make noises
*#
#def makeNoises
  ##
const double _dVdt = 1.0/_var;
for (long _i0 = 0; _i0 < _n; _i0++) {
  _noise_vector[_i0] = _var * _poidev(${noiseMeanRate} * _dVdt, ${generatorName});
}
  ##
#end def

#@callOncePerClassGuard
#def static_functionPrototypes
  ##
  #super
double _poidev(double xm, unsigned short* _generator);
  ##
#end def

#@callOncePerClassGuard
#def static_functionImplementations
  ##
  #super
double _poidev(double xm, unsigned short* _generator)
{
  static double sq, alxm, g;
  double em, t, y;
  if (xm < 12.0) {        // Use direct method
    g = exp(-xm);
    em = -1.0;
    t = 1.0;
    // Instead of adding exponential deviates it is equivalent
    // to multiply uniform deviates.  We never actually have to
    // take the log, merely compare to the pre-computed exponential
    do {
      ++em;
      t *= erand48(_generator);
    } while (t > g);
  } else {
    // Use rejection method
    sq = sqrt(2.0*xm);
    alxm = log(xm);
    g = xm*alxm - lgamma(xm + 1.0);
    do {
      do {
        // y is a deviate from a Lorenzian comparison function
        y = tan(M_PI*erand48(_generator));
        // em is y, shifted and scaled
        em = sq*y + xm;
      } while (em < 0.0);  // Reject if in regime of zero probability
      em = floor(em);      // The trick for integer-valued distributions
      t = 0.9*(1.0 + y*y)*exp(em*alxm - lgamma(em + 1.0) - g);
      // The ratio of the desired distribution to the comparison
      // function; we reject by comparing it to another uniform
      // deviate. The factor 0.9 so that t never exceeds 1.
    } while (erand48(_generator) > t);
  }
  return em;
}
  ##
#end def