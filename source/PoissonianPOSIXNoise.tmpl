@*
PoissonianPOSIXNoise.tmpl

Created by Graham Dennis on 2007-12-14.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends POSIXNoise
@from Decorators import callOncePerClassGuard

@def description: Poissonian noise
@attr $noiseDistribution = 'poissonian'

@*
  Make noises
*@
@def makeNoises
  @#
const double _dVdt = 1.0/_var;
for (long _i0 = 0; _i0 < _n; _i0++) {
  _noise_vector[_i0] = _var * _poidev(${noiseMeanRate} * _dVdt, ${generatorName});
}
  @#
@end def

@@callOncePerClassGuard
@def static_functionPrototypes
  @#
  @super
double _poidev(double xm, unsigned short* _generator);
double _poisplit(double pp, int n, unsigned short* _generator);
  @#
@end def

@def functionPrototypes
  @#
  @super
  @#
inline void _split_${prefix}_noise(double dV, double _new_step, double _old_step, double* _new_noise_vector, double* _old_noise_vector, unsigned long _n);
  @#
@end def

@def functionImplementations
  @#
  @super
  @#
inline void _split_${prefix}_noises(double _new_var, double _old_var, double* _new_noise_vector, double* _old_noise_vector, unsigned long _n)
{
  for (long _i0 = 0; _i0 < _n; _i0++) { 
    _new_noise_vector[_i0] = _new_var*_poisplit(_old_var/_new_var, lround(_old_noise_vector[_i0]/_old_var), ${generatorName});
  }

}
  @#
@end def

@@callOncePerClassGuard
@def static_functionImplementations
  @#
  @super
double _poidev(double xm, unsigned short* _generator)
{
  static double sq, alxm, g;
  double em, t, y;
  if (xm < 12.0) {        // Use direct method
    g = exp(-xm);
    em = -1.0;
    t = 1.0;
    // Instead of adding exponential deviates it is equivalent
    // to multiply uniform deviates.  We never actually have to
    // take the log, merely compare to the pre-computed exponential
    do {
      ++em;
      t *= erand48(_generator);
    } while (t > g);
  } else {
    // Use rejection method
    sq = sqrt(2.0*xm);
    alxm = log(xm);
    g = xm*alxm - lgamma(xm + 1.0);
    do {
      do {
        // y is a deviate from a Lorenzian comparison function
        y = tan(M_PI*erand48(_generator));
        // em is y, shifted and scaled
        em = sq*y + xm;
      } while (em < 0.0);  // Reject if in regime of zero probability
      em = floor(em);      // The trick for integer-valued distributions
      t = 0.9*(1.0 + y*y)*exp(em*alxm - lgamma(em + 1.0) - g);
      // The ratio of the desired distribution to the comparison
      // function; we reject by comparing it to another uniform
      // deviate. The factor 0.9 so that t never exceeds 1.
    } while (erand48(_generator) > t);
  }
  return em;
}

double _poisplit(double pp, int n, unsigned short* _generator)
{
/*Returns as a floating-point number an integer value that is a random deviate drawn from 
a binomial distribution of n trials each of probability pp, using erand48(_generator) as a source of 
uniform random deviates. This is exactly the distribution that must be sampled when a poissonian process is split over two smaller time steps */

  int j; 
  double am,em,g,p,bnl,sq,t,y; 
  static double pc,plog,pclog,en,oldg; 
  p=(pp <= 0.5 ? pp : 1.0-pp);	// The binomial distribution is invariant under changing pp to 1-pp, if we also change the answer to n minus itself; we'll remember to do this below. 
  am=n*p; //This is the mean of the deviate to be produced. 
  if (n < 25) { //Use the direct method while n is not too large. This can require up to 25 calls to erand48(_generator).
    bnl=0.0; 
    for (j=1;j<=n;j++) 
      if (erand48(_generator) < p) ++bnl; 
  } else if (am < 1.0) { //If fewer than one event is expected out of 25 or more trials, then the distribution is quite accurately Poisson. Use direct Poisson method. 
    g=exp(-am); 
    t=1.0; 
    for (j=0;j<=n;j++) { 
      t *= erand48(_generator); 
      if (t < g) break; 
    } 
    bnl=(j <= n ? j : n); 
  } else { 
    en=n; 
    oldg=lgamma(en+1.0);  
    pc=1.0-p; 
    plog=log(p); 
    pclog=log(pc);   
    sq=sqrt(2.0*am*pc); //The following code should by now seem familiar: rejection method with a Lorentzian comparison function. 
    do { 
      do { 
        y=tan(M_PI*erand48(_generator)); 
        em=sq*y+am; 
      } while (em < 0.0 || em >= (en+1.0)); //Reject. 
      em=floor(em); //Trick for integer-valued distribution. 
      t=1.2*sq*(1.0+y*y)*exp(oldg-lgamma(em+1.0)-lgamma(en-em+1.0)+em*plog+(en-em)*pclog); 
    } while (erand48(_generator) > t); // Reject. This happens about 1.5 times per deviate, on average.
    bnl=em; 
  }
  if (p != pp) bnl=n-bnl; //Remember to undo the symmetry transformation.
  return bnl;
}  

  @#
@end def

