@*
FixedStep.tmpl

Created by Graham Dennis on 2007-10-20.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends _FixedStep

@def description: segment $segmentNumber (Unnamed fixed-step integrator)


@def functionPrototypes
  @#
  @super
  @#
  @if $cross
void _${name}_initialise_cross_propagation();
  @end if
  @#
@end def

@def functionImplementations
  @#
  @super
  @#
  @if $cross

${initialiseCrossPropagationFunctionImplementation}@slurp

  @end if
  @#
@end def

@def localInitialise
@*doc:
  This function returns the local initialisation code for the integrator.
*@
  @#
  @super
  @#
  @if $cross

_${name}_initialise_cross_propagation();

    @set $integrationDimension = $parent.field.dimensionWithName($propagationDimension)
    @# FIXME: This variable is only available inside the integrator... what about the delta a operator?
${integrationDimension.type} ${integrationDimension.name} = _${parent.field.name}_xmin${parent.field.indexOfDimension($integrationDimension)};
  @end if
  @#
@end def


@def createStepVariable
@*doc:
This function returns the code that will create a _step variable,
including any modifications necessary due to the ErrorCheck feature.
*@
  @#
double _step = ${step};
double _noiseStep = ${step};
  @#
  @set $featureOrdering = ['ErrorCheck']
  @#
${insertCodeForFeatures('createFixedStepVariable', featureOrdering)}@slurp
  @#
@end def


@def segmentFunctionImplementation
  @#
void _segment${segmentNumber}()
{
  ${createStepVariable, autoIndent=True}@slurp
  @#
  @set $featureOrderingOuter = ['Stochastic']
  ${insertCodeForFeatures('integrateFixedStepBegin', featureOrderingOuter), autoIndent=True}@slurp
  
  ${initialise, autoIndent=True}@slurp
  
  ${localInitialise, autoIndent=True}@slurp
  
  for (long _istep = 0; _istep < ${stepCount}; _istep++) {
  @# Insert code for features
  @set $featureOrderingInner = ['Output', 'ErrorCheck', 'Stochastic']
  @#
  @set $dict = {'extraIndent': 0}
    ${insertCodeForFeatures('integrateFixedStepInnerLoopBegin', featureOrderingInner, dict), autoIndent=True}@slurp
  @set $extraIndent = $dict.extraIndent
    
    ${preSingleStep, autoIndent=True, extraIndent=extraIndent}@slurp
    ${singleIntegrationStep, autoIndent=True, extraIndent=extraIndent}@slurp
    ${postSingleStep, autoIndent=True, extraIndent=extraIndent}@slurp
    
  @if $cross
    @# If we are cross-integrating, then we now need to copy our result back
    @# into the original arrays for the integration vectors
    ${copyResultIntoIntegrationArrays, autoIndent=True, extraIndent=extraIndent}@slurp
    
  @end if
  @#
    ${insertCodeForFeaturesInReverseOrder('integrateFixedStepInnerLoopEnd', featureOrderingInner, dict), autoIndent=True}@slurp
  }

  ${finalise, autoIndent=True}@slurp
  
  ${insertCodeForFeaturesInReverseOrder('integrateFixedStepEnd', featureOrderingOuter), autoIndent=True}@slurp
}
  @#
@end def


@# ---- Cross-propagation methods ----

@def reducedFieldCopy($vectorMap, $templateString, $positiveIndexOverride = None, $negativeIndexOverride = None)
  @#
  @if $propagationDirection == '+'
    @if $positiveIndexOverride
      @set $indexOverrideValue = $positiveIndexOverride
    @else
      @set $indexOverrideValue = '_istep'
    @end if
  @else
    @if $negativeIndexOverride
      @set $indexOverrideValue = $negativeIndexOverride
    @else
      @set $integrationDimensionNumber = $parent.field.indexOfDimensionName($propagationDimension)
      @set $indexOverrideValue = c'(_${parent.field.name}_lattice${integrationDimensionNumber} - _istep - 1)'
    @end if
  @end if
  @#
  @# Create the index overrides dictionary. We only need to override the propagation dimension
  @set $indexOverrides = {$propagationDimension: dict([(v.field, indexOverrideValue) for v in vectorMap.values()])}
  @#
  @set $setOfVectorsToLoopOver = set(vectorMap.keys())
  @silent setOfVectorsToLoopOver.update(vectorMap.values())
  @#
  @set $innerLoopTemplate = $templateObjectFromStringWithTemplateVariables($templateString, {'componentIndex': '_icomp'})
  @#
  @capture loopContents
    @for $reducedVector, $vector in $vectorMap.iteritems()
      @set $indices = range(0, len(vector.field.dimensions))
      @if vector.field.hasDimensionName($propagationDimension)
        @silent indices.remove(vector.field.indexOfDimensionName($propagationDimension))
      @end if
      @silent innerLoopTemplate.skipSize = $propagationDirection + $vector.field.pointsInDimensionsWithIndices($indices)
      @silent innerLoopTemplate.reducedVector = reducedVector
      @silent innerLoopTemplate.vector = vector
for (long _icomp = 0; _icomp < _${vector.id}_ncomponents; _icomp++) {
  ${innerLoopTemplate, autoIndent=True}@slurp
}
    @end for
  @end capture
  @#
${loopOverFieldInSpaceWithVectorsAndInnerContent($parent.reducedField, $homeSpace, $setOfVectorsToLoopOver,
                                                 $loopContents, indexOverrides = $indexOverrides,
                                                 vectorsNotNeedingDefines = $setOfVectorsToLoopOver)}@slurp
  @#
@end def


@def initialiseCrossPropagationFunctionImplementation
@*doc:
  Return code for initialising the boundary conditions of a cross-propagation integrator.

  This code both sets the boundary conditions and copies in the first values for the
  dependencies into the local dependency arrays.
*@
  @#
void _${name}_initialise_cross_propagation()
{
  @set $positiveIndexOverride = '0'
  @set $integrationDimensionNumber = $parent.field.indexOfDimensionName($propagationDimension)
  @set $negativeIndexOverride = c'(_${parent.field.name}_lattice${integrationDimensionNumber} - 1)'
  @#
  @set $combinedLoopVectorMap = $integrationVectorMap.copy()
  @silent combinedLoopVectorMap.update($dependencyMap)
  // Copy the initial value of the cross-propagation integration vectors and dependencies into our local arrays
  {
    ${reducedFieldCopy($combinedLoopVectorMap,
"""_active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}] = _active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex}];
""", positiveIndexOverride = $positiveIndexOverride, negativeIndexOverride = $negativeIndexOverride), autoIndent=True}@slurp
  }
  
  @#
  @if $propagationDirection == '+'
    @set $indexOverrideValue = $positiveIndexOverride
  @else
    @set $indexOverrideValue = $negativeIndexOverride
  @end if
  @#
  @# Create the index overrides dictionary for the boundary conditions. We only need to override the propagation dimension.
  @set $indexOverrides = {$propagationDimension: dict([(v.field, indexOverrideValue) for v in $parent.boundaryConditionDependencies])}
  @#
  @set $setOfVectorsToLoopOver = $integrationVectors.copy()
  @silent setOfVectorsToLoopOver.update($parent.boundaryConditionDependencies)
  @#
  // Set the boundary condition
  {
    ${loopOverFieldInSpaceWithVectorsAndInnerContent($parent.reducedField, $homeSpace, $setOfVectorsToLoopOver,
                                                     $parent.boundaryConditionCode, indexOverrides = $indexOverrides), autoIndent=True}@slurp
  }

  // Copy the initial value of the integration vectors back into their main arrays
  {
    ${reducedFieldCopy($integrationVectorMap,
"""_active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex}] = _active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}];
""", positiveIndexOverride = $positiveIndexOverride, negativeIndexOverride = $negativeIndexOverride), autoIndent=True}@slurp
  }
  
}
  @#
@end def


@def copyResultIntoIntegrationArrays
@*doc:
  Returns code to copy the result of our cross-propagation step back into the original arrays
  for the integation vectors.
*@
  @#
// Copy the result back into the original array.
{
  ${reducedFieldCopy($integrationVectorMap, 
"""
_active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex} + ${skipSize} * _${vector.id}_ncomponents] = \
  _active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}];
"""), autoIndent=True}@slurp
}
  @#
@end def


@def updateDependenciesForNextStep
@*doc:
  Return code to update our dependencies vectors from the originals for the next step.
*@
  @#
// Update the dependencies for the next step
{
  ${reducedFieldCopy($dependencyMap,
"""
_active_${reducedVector.id}[_${reducedVector.id}_index_pointer + ${componentIndex}] = \
  _active_${vector.id}[_${vector.id}_index_pointer + ${componentIndex} + ${skipSize} * _${vector.id}_ncomponents];
"""), autoIndent=True}@slurp
}
  @#
@end def

