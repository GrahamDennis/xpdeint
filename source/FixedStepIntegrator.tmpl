@*
FixedStepIntegrator.tmpl

Created by Graham Dennis on 2007-10-20.
Copyright (c) 2007 __MyCompanyName__. All rights reserved.
*@
@extends _FixedStepIntegrator

@def description: segment $segmentNumber (Unnamed fixed-step integrator)


@def localInitialise
@*doc:
  This function returns the local initialisation code for the integrator.
*@
  @#
  @super
  @#
  @if $cross

${initialiseCrossPropagation}@slurp
  @end if
  @#
@end def


@def initialiseCrossPropagation
@*doc:
  Return code for initialising the boundary conditions of a cross-propagation integrator.
  
  This code both sets the boundary conditions and copies in the first values for the
  dependencies into the local dependency arrays.
*@
  @#
  @if $propagationDirection == '+'
    @set $indexOverrideValue = '0'
  @else
    @set $integrationDimensionNumber = $parent.field.indexOfDimensionName($propagationDimension)
    @set $indexOverrideValue = c'(_${parent.field.name}_lattice${integrationDimensionNumber} - 1)'
  @end if
  @#
  @# Create the index overrides dictionary. We only need to override the propagation dimension.
  @set $indexOverrides = {$propagationDimension: dict([(v.field, indexOverrideValue) for v in $parent.boundaryConditionDependencies])}
  @#
  @set $setOfVectorsToLoopOver = $vectors.copy()
  @silent setOfVectorsToLoopOver.update($parent.boundaryConditionDependencies)
  @#
  @# FIXME: The order of the boundary-condition setting isn't the best. The order should go:
  @# 1. Copy stuff out of the cross-propagation integration vectors into our 'reduced' vectors
  @# 2. Apply boundary condition code
  @# 3. Copy result back into the full integration vectors.
  @#
{
  // Set the boundary condition
  ${loopOverFieldInSpaceWithVectorsAndInnerContent($parent.reducedField, $homeSpace, $setOfVectorsToLoopOver,
                                                   $parent.boundaryConditionCode, indexOverrides = $indexOverrides), autoIndent=True}@slurp
}

  @# Create the index overrides dictionary. We only need to override the propagation dimension.
  @set $indexOverrides = {$propagationDimension: dict([(v.field, indexOverrideValue) for v in $parent.dependencies])}
  @#
  @set $setOfVectorsToLoopOver = $dependencies.copy()
  @silent setOfVectorsToLoopOver.update($parent.dependencies)
  @silent setOfVectorsToLoopOver.update($integrationVectorMap.keys())
  @silent setOfVectorsToLoopOver.update($integrationVectorMap.values())
  @#
  @capture loopString
// Copy the dependencies
    @for $reducedVector, $vector in $dependencyMap.iteritems()
for (long _icomp = 0; _icomp < _${vector.id}_ncomponents; _icomp++) {
  _active_${reducedVector.id}[_${reducedVector.id}_index_pointer + _icomp] = _active_${vector.id}[_${vector.id}_index_pointer + _icomp];
}
    @end for
    @#

// Copy the boundary conditions back.
    @for $reducedVector, $vector in $integrationVectorMap.iteritems()
for (long _icomp = 0; _icomp < _${vector.id}_ncomponents; _icomp++) {
  _active_${vector.id}[_${vector.id}_index_pointer + _icomp] = _active_${reducedVector.id}[_${vector.id}_index_pointer + _icomp];
}
    @end for
  @end capture
  @#
{
  // Copy the part of the dependencies we need into our local array and copy the boundary condition back into the original array
  ${loopOverFieldInSpaceWithVectorsAndInnerContent($parent.reducedField, $homeSpace, $setOfVectorsToLoopOver,
                                                   $loopString, indexOverrides = $indexOverrides,
                                                   vectorsNotNeedingDefines = $setOfVectorsToLoopOver), autoIndent=True}@slurp
}

  @set $integrationDimension = $parent.field.dimensionWithName($propagationDimension)
  @# FIXME: This variable is only available inside the integrator... what about the delta a operator?
${integrationDimension.type} ${integrationDimension.name} = _${parent.field.name}_xmin${parent.field.indexOfDimension($integrationDimension)};

  @#
@end def


@def createStepVariable
@*doc:
This function returns the code that will create a _step variable,
including any modifications necessary due to the ErrorCheck feature.
*@
  @#
double _step = ${step};
double _noiseStep = ${step};
  @#
  @set $featureOrdering = ['ErrorCheck']
  @#
${insertCodeForFeatures('createFixedStepVariable', featureOrdering)}@slurp
  @#
@end def


@def segmentFunctionImplementation
  @#
void _segment${segmentNumber}()
{
  ${createStepVariable, autoIndent=True}@slurp
  @#
  @set $featureOrderingOuter = ['Stochastic']
  ${insertCodeForFeatures('integrateFixedStepBegin', featureOrderingOuter), autoIndent=True}@slurp
  
  ${initialise, autoIndent=True}@slurp
  
  ${localInitialise, autoIndent=True}@slurp
  
  for (long _istep = 0; _istep < ${stepCount}; _istep++) {
  @# Insert code for features
  @set $featureOrderingInner = ['Output', 'ErrorCheck', 'Stochastic']
  @#
  @set $dict = {'extraIndent': 0}
    ${insertCodeForFeatures('integrateFixedStepInnerLoopBegin', featureOrderingInner, dict), autoIndent=True}@slurp
  @set $extraIndent = $dict.extraIndent
    
    ${singleIntegrationStep, autoIndent=True, extraIndent=extraIndent}@slurp
    
  @if $cross
    @# If we are cross-integrating, then we now need to copy our result back
    @# into the original arrays for the integration vectors
    ${copyResultIntoIntegrationArrays, autoIndent=True, extraIndent=extraIndent}@slurp
    
  @end if
  @#
    ${insertCodeForFeaturesInReverseOrder('integrateFixedStepInnerLoopEnd', featureOrderingInner, dict), autoIndent=True}@slurp
  }

  ${finalise, autoIndent=True}@slurp
  
  ${insertCodeForFeaturesInReverseOrder('integrateFixedStepEnd', featureOrderingOuter), autoIndent=True}@slurp
}
  @#
@end def


@# ---- Cross-propagation methods ----

@def copyResultIntoIntegrationArrays
@*doc:
  Returns code to copy the result of our cross-propagation step back into the original arrays
  for the integation vectors.
*@
  @#
  @if $propagationDirection == '+'
    @set $indexOverrideValue = '_istep'
  @else
    @set $integrationDimensionNumber = $parent.field.indexOfDimensionName($propagationDimension)
    @set $indexOverrideValue = c'(_${parent.field.name}_lattice${integrationDimensionNumber} - _istep - 1)'
  @end if
  @#
  @# Create the index overrides dictionary. We only need to override the propagation dimension.
  @set $indexOverrides = {$propagationDimension: dict([(v.field, indexOverrideValue) for v in $parent.integrationVectors])}
  @#
  @set $setOfVectorsToLoopOver = $vectors.copy()
  @silent setOfVectorsToLoopOver.update($parent.integrationVectors)
  @#
  @capture loopString
    @for $reducedVector, $vector in $integrationVectorMap.iteritems()
    @set $indices = range(0, len($vector.field.dimensions))
    @if $vector.field.hasDimensionName($propagationDimension)
      @silent indices.remove(vector.field.indexOfDimensionName($propagationDimension))
    @end if
    @set $skipSize = $propagationDirection + $vector.field.pointsInDimensionsWithIndices($indices)
for (long _icomp = 0; _icomp < _${vector.id}_ncomponents; _icomp++) {
  _active_${vector.id}[_${vector.id}_index_pointer + _icomp + $skipSize * _${vector.id}_ncomponents] = \
    _active_${reducedVector.id}[_${reducedVector.id}_index_pointer + _icomp];
}
    @end for
  @end capture
  @#
${loopOverFieldInSpaceWithVectorsAndInnerContent($parent.reducedField, $homeSpace, $setOfVectorsToLoopOver,
                                                 $loopString, indexOverrides = $indexOverrides,
                                                 vectorsNotNeedingDefines = $setOfVectorsToLoopOver)}@slurp
  @#
@end def


@def updateDependenciesForNextStep
@*doc:
  Return code to update our dependencies vectors from the originals for the next step.
*@
  @#
  @if $propagationDirection == '+'
    @set $indexOverrideValue = '_istep'
  @else
    @set $integrationDimensionNumber = $parent.field.indexOfDimensionName($propagationDimension)
    @set $indexOverrideValue = c'(_${parent.field.name}_lattice${integrationDimensionNumber} - _istep - 1)'
  @end if
  @#
  @# Create the index overrides dictionary. We only need to override the propagation dimension.
  @set $indexOverrides = {$propagationDimension: dict([(v.field, indexOverrideValue) for v in $parent.dependencies])}
  @#
  @set $setOfVectorsToLoopOver = $dependencies.copy()
  @silent setOfVectorsToLoopOver.update($parent.dependencies)
  @#
  @capture loopString
    @for $reducedVector, $vector in $dependencyMap.iteritems()
      @set $indices = range(0, len($vector.field.dimensions))
      @if $vector.field.hasDimensionName($propagationDimension)
        @silent indices.remove(vector.field.indexOfDimensionName($propagationDimension))
      @end if
      @set $skipSize = $propagationDirection + $vector.field.pointsInDimensionsWithIndices($indices)
for (long _icomp = 0; _icomp < _${vector.id}_ncomponents; _icomp++) {
  _active_${reducedVector.id}[_${reducedVector.id}_index_pointer + _icomp] = \
    _active_${vector.id}[_${vector.id}_index_pointer + _icomp + $skipSize * _${vector.id}_ncomponents];
}
    @end for
  @end capture
  @#

{
  // Update the dependencies for the next step
  ${loopOverFieldInSpaceWithVectorsAndInnerContent($parent.reducedField, $homeSpace, $setOfVectorsToLoopOver,
                                                   $loopString, indexOverrides = $indexOverrides,
                                                   vectorsNotNeedingDefines = $setOfVectorsToLoopOver), autoIndent=True}@slurp
}
  @#
@end def

